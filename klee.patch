diff --git a/.gitignore b/.gitignore
index a3037485..e5971e1b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -30,3 +30,5 @@ lit.site.cfg
 autoconf/aclocal.m4
 autoconf/autom4te.cache/
 autom4te.cache/
+
+.vscode/
diff --git a/include/klee/Expr/ExprSMTLIBPrinter.h b/include/klee/Expr/ExprSMTLIBPrinter.h
index 290caf7b..c07d5c32 100644
--- a/include/klee/Expr/ExprSMTLIBPrinter.h
+++ b/include/klee/Expr/ExprSMTLIBPrinter.h
@@ -210,6 +210,12 @@ public:
   /// \return True if human readable mode is switched on
   bool isHumanReadable();
 
+  /// Print expression without top-level abbreviations
+  void printFullExpression(const ref<Expr> &e, SMTLIB_SORT expectedSort);
+
+  /// Determine the SMTLIBv2 sort of the expression
+  SMTLIB_SORT getSort(const ref<Expr> &e);
+  
 protected:
   /// Contains the arrays found during scans
   std::set<const Array *> usedArrays;
@@ -235,9 +241,6 @@ protected:
   /// The query to print
   const Query *query;
 
-  /// Determine the SMTLIBv2 sort of the expression
-  SMTLIB_SORT getSort(const ref<Expr> &e);
-
   /// Print an expression but cast it to a particular SMTLIBv2 sort first.
   void printCastToSort(const ref<Expr> &e, ExprSMTLIBPrinter::SMTLIB_SORT sort);
 
@@ -369,8 +372,6 @@ private:
   const char *
   getSMTLIBOptionString(ExprSMTLIBPrinter::SMTLIBboolOptions option);
 
-  /// Print expression without top-level abbreviations
-  void printFullExpression(const ref<Expr> &e, SMTLIB_SORT expectedSort);
 
   /// Print an assert statement for the given expr.
   void printAssert(const ref<Expr> &e);
diff --git a/include/klee/Expr/ExprUtil.h b/include/klee/Expr/ExprUtil.h
index c6b2c2d7..5ef08850 100644
--- a/include/klee/Expr/ExprUtil.h
+++ b/include/klee/Expr/ExprUtil.h
@@ -40,6 +40,18 @@ namespace klee {
                            InputIterator end,
                            std::vector<const Array*> &results);
 
+  template<typename InputIterator>
+  void findSymbolicObjectIndices(InputIterator begin, 
+                                InputIterator end,
+                                std::vector<const Array*> &results_arrays,
+                                std::vector<UpdateList> &updatelists,
+                                std::vector<ref<Expr>> &indices);
+
+  void findSymbolicObjectIndices(ref<Expr> e,
+                               std::vector<const Array*> &results_arrays,
+                               std::vector<UpdateList> &updatelists,
+                               std::vector<ref<Expr>> &indices);
+
   class ConstantArrayFinder : public ExprVisitor {
   protected:
     ExprVisitor::Action visitRead(const ReadExpr &re);
diff --git a/include/klee/Module/KModule.h b/include/klee/Module/KModule.h
index 71fe8a0a..ea5c90d9 100644
--- a/include/klee/Module/KModule.h
+++ b/include/klee/Module/KModule.h
@@ -94,6 +94,7 @@ namespace klee {
   public:
     std::unique_ptr<llvm::Module> module;
     std::unique_ptr<llvm::DataLayout> targetData;
+    std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> header_to_exiting_and_exits; // map header bb to exiting, exit bbs
 
     // Our shadow versions of LLVM structures.
     std::vector<std::unique_ptr<KFunction>> functions;
diff --git a/include/klee/klee.h b/include/klee/klee.h
index 07528595..876127b8 100644
--- a/include/klee/klee.h
+++ b/include/klee/klee.h
@@ -117,6 +117,9 @@ extern "C" {
   void klee_warning_once(const char *message);
   void klee_prefer_cex(void *object, uintptr_t condition);
   void klee_posix_prefer_cex(void *object, uintptr_t condition);
+  void klee_pass_token(int token);
+  uint32_t klee_get_next_token_ctr();
+  void klee_mark_cursor(void *object, size_t size);
   void klee_mark_global(void *object);
 
   /* Return a possible constant value for the input expression. This
diff --git a/klee.patch b/klee.patch
new file mode 100644
index 00000000..4d188091
--- /dev/null
+++ b/klee.patch
@@ -0,0 +1,1507 @@
+diff --git a/.gitignore b/.gitignore
+index a3037485..7eed4ac7 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -30,3 +30,6 @@ lit.site.cfg
+ autoconf/aclocal.m4
+ autoconf/autom4te.cache/
+ autom4te.cache/
++
++isla/
++.vscode/
+diff --git a/include/klee/Expr/ExprSMTLIBPrinter.h b/include/klee/Expr/ExprSMTLIBPrinter.h
+index 290caf7b..c07d5c32 100644
+--- a/include/klee/Expr/ExprSMTLIBPrinter.h
++++ b/include/klee/Expr/ExprSMTLIBPrinter.h
+@@ -210,6 +210,12 @@ public:
+   /// \return True if human readable mode is switched on
+   bool isHumanReadable();
+ 
++  /// Print expression without top-level abbreviations
++  void printFullExpression(const ref<Expr> &e, SMTLIB_SORT expectedSort);
++
++  /// Determine the SMTLIBv2 sort of the expression
++  SMTLIB_SORT getSort(const ref<Expr> &e);
++  
+ protected:
+   /// Contains the arrays found during scans
+   std::set<const Array *> usedArrays;
+@@ -235,9 +241,6 @@ protected:
+   /// The query to print
+   const Query *query;
+ 
+-  /// Determine the SMTLIBv2 sort of the expression
+-  SMTLIB_SORT getSort(const ref<Expr> &e);
+-
+   /// Print an expression but cast it to a particular SMTLIBv2 sort first.
+   void printCastToSort(const ref<Expr> &e, ExprSMTLIBPrinter::SMTLIB_SORT sort);
+ 
+@@ -369,8 +372,6 @@ private:
+   const char *
+   getSMTLIBOptionString(ExprSMTLIBPrinter::SMTLIBboolOptions option);
+ 
+-  /// Print expression without top-level abbreviations
+-  void printFullExpression(const ref<Expr> &e, SMTLIB_SORT expectedSort);
+ 
+   /// Print an assert statement for the given expr.
+   void printAssert(const ref<Expr> &e);
+diff --git a/include/klee/Expr/ExprUtil.h b/include/klee/Expr/ExprUtil.h
+index c6b2c2d7..5ef08850 100644
+--- a/include/klee/Expr/ExprUtil.h
++++ b/include/klee/Expr/ExprUtil.h
+@@ -40,6 +40,18 @@ namespace klee {
+                            InputIterator end,
+                            std::vector<const Array*> &results);
+ 
++  template<typename InputIterator>
++  void findSymbolicObjectIndices(InputIterator begin, 
++                                InputIterator end,
++                                std::vector<const Array*> &results_arrays,
++                                std::vector<UpdateList> &updatelists,
++                                std::vector<ref<Expr>> &indices);
++
++  void findSymbolicObjectIndices(ref<Expr> e,
++                               std::vector<const Array*> &results_arrays,
++                               std::vector<UpdateList> &updatelists,
++                               std::vector<ref<Expr>> &indices);
++
+   class ConstantArrayFinder : public ExprVisitor {
+   protected:
+     ExprVisitor::Action visitRead(const ReadExpr &re);
+diff --git a/include/klee/Module/KModule.h b/include/klee/Module/KModule.h
+index 71fe8a0a..ea5c90d9 100644
+--- a/include/klee/Module/KModule.h
++++ b/include/klee/Module/KModule.h
+@@ -94,6 +94,7 @@ namespace klee {
+   public:
+     std::unique_ptr<llvm::Module> module;
+     std::unique_ptr<llvm::DataLayout> targetData;
++    std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> header_to_exiting_and_exits; // map header bb to exiting, exit bbs
+ 
+     // Our shadow versions of LLVM structures.
+     std::vector<std::unique_ptr<KFunction>> functions;
+diff --git a/include/klee/klee.h b/include/klee/klee.h
+index 07528595..876127b8 100644
+--- a/include/klee/klee.h
++++ b/include/klee/klee.h
+@@ -117,6 +117,9 @@ extern "C" {
+   void klee_warning_once(const char *message);
+   void klee_prefer_cex(void *object, uintptr_t condition);
+   void klee_posix_prefer_cex(void *object, uintptr_t condition);
++  void klee_pass_token(int token);
++  uint32_t klee_get_next_token_ctr();
++  void klee_mark_cursor(void *object, size_t size);
+   void klee_mark_global(void *object);
+ 
+   /* Return a possible constant value for the input expression. This
+diff --git a/lib/Core/ExecutionState.cpp b/lib/Core/ExecutionState.cpp
+index 5231f7fb..750b4a4b 100644
+--- a/lib/Core/ExecutionState.cpp
++++ b/lib/Core/ExecutionState.cpp
+@@ -58,7 +58,8 @@ StackFrame::StackFrame(const StackFrame &s)
+     callPathNode(s.callPathNode),
+     allocas(s.allocas),
+     minDistToUncoveredOnReturn(s.minDistToUncoveredOnReturn),
+-    varargs(s.varargs) {
++    varargs(s.varargs),
++    functionPath(s.functionPath) {
+   locals = new Cell[s.kf->numRegisters];
+   for (unsigned i=0; i<s.kf->numRegisters; i++)
+     locals[i] = s.locals[i];
+@@ -105,7 +106,16 @@ ExecutionState::ExecutionState(const ExecutionState& state):
+                              ? state.unwindingInformation->clone()
+                              : nullptr),
+     coveredNew(state.coveredNew),
+-    forkDisabled(state.forkDisabled) {
++    forkDisabled(state.forkDisabled),
++    eventStack(state.eventStack), // added
++    mo_cursor(state.mo_cursor), // added
++    mo_cursor_offset(state.mo_cursor_offset), // added
++    mo_cursor_size(state.mo_cursor_size), // added
++    token_count(state.token_count), // added
++    reachedFUA(state.reachedFUA), // added
++    highest_input_pos_written(state.highest_input_pos_written), // added
++    finalFunctionPath(state.finalFunctionPath) // added
++    {
+   for (const auto &cur_mergehandler: openMergeStack)
+     cur_mergehandler->addOpenState(this);
+ }
+@@ -136,6 +146,39 @@ void ExecutionState::addSymbolic(const MemoryObject *mo, const Array *array) {
+   symbolics.emplace_back(ref<const MemoryObject>(mo), array);
+ }
+ 
++std::vector<std::string> ExecutionState::getCallStack(std::string ParserFunctionUnderAnalysis) {
++  std::vector<std::string> callstack;
++  StackFrame& sf_top = stack.back();
++
++  for (const StackFrame &sf : stack) {
++    if (sf.kf->function->getName().str() == ParserFunctionUnderAnalysis) {
++      // We add the function-local path of the FUA to the context.
++      // We only ever call the current function from the FUA, or a tokenization function called by the FUA.
++      // If we're in a tokenization function, we still use only the FUA path.
++      // The reason: Only in FUA, loops are bounded.
++      std::string s_functionPath;
++      for (bool b: sf.functionPath) {
++        if (b) s_functionPath += "1";
++        else s_functionPath += "0";
++      }
++      callstack.push_back(s_functionPath);
++      break;
++    }
++  }
++  
++  if (sf_top.kf->function->getName().str() == ParserFunctionUnderAnalysis) {
++    // Add current instruction in current function (we need both: functionPath and this)
++    Instruction *cur_inst = prevPC ? prevPC->inst : nullptr;
++    std::string s;
++    llvm::raw_string_ostream llvm_s(s);
++    llvm_s << cur_inst;
++    callstack.push_back(llvm_s.str()); 
++  }
++
++  return callstack;
++}
++
++
+ /**/
+ 
+ llvm::raw_ostream &klee::operator<<(llvm::raw_ostream &os, const MemoryMap &mm) {
+diff --git a/lib/Core/ExecutionState.h b/lib/Core/ExecutionState.h
+index 49e232dc..52c58c2e 100644
+--- a/lib/Core/ExecutionState.h
++++ b/lib/Core/ExecutionState.h
+@@ -21,6 +21,8 @@
+ #include "klee/Solver/Solver.h"
+ #include "klee/System/Time.h"
+ 
++#include "llvm/IR/BasicBlock.h"
++
+ #include <map>
+ #include <memory>
+ #include <set>
+@@ -60,6 +62,8 @@ struct StackFrame {
+   // of intrinsic lowering.
+   MemoryObject *varargs;
+ 
++  std::vector<bool> functionPath;
++
+   StackFrame(KInstIterator caller, KFunction *kf);
+   StackFrame(const StackFrame &s);
+   ~StackFrame();
+@@ -143,6 +147,162 @@ struct CleanupPhaseUnwindingInformation : public UnwindingInformation {
+   }
+ };
+ 
++
++class EventBase {
++  public:
++    virtual ~EventBase() = default;
++    virtual std::string to_json() const = 0;
++    static std::string callStackToString(std::vector<std::string> call_stack) {
++      std::string s_callstack;
++      for (const auto& s : call_stack) {
++          s_callstack += s;
++          s_callstack += ',';
++      }
++      return s_callstack;
++    }
++};
++
++class EventToken: public EventBase {
++  public:
++    int id;
++    std::vector<uint32_t> possible_tokens;
++
++    EventToken(int id):
++      id(id) {}
++
++    // We concretize only at the end, to capture all constraints.
++    void add_possible_token(uint32_t tok) {
++      possible_tokens.push_back(tok);
++    }
++
++    void clear_possible_tokens() {
++      // This is required because EventTokens are shared among forked states.
++      // It should be called during serialization.
++      possible_tokens.clear();
++    }
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventToken\", \"id\": " << id << ", \"possible_tokens\": [";
++      size_t i = 0;
++      for (uint32_t tok: possible_tokens) {
++        json << tok;
++        if (i != possible_tokens.size()-1) json << ", ";
++        i++;
++      }
++      json << "]}";
++      return json.str();
++    }
++};
++
++class EventPassToken: public EventBase {
++  // This event is generated by klee_pass_token.
++  // This is used when we analyze get_next_token in isolation.
++  // We pass the "token id" here.
++  public:
++    uint32_t id;
++
++    EventPassToken(uint32_t id):
++      id(id) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventPassToken\", \"id\": " << id << "}";
++      return json.str();
++    }
++};
++
++class EventCharacter: public EventBase {
++  public:
++    ref<Expr> e;
++    unsigned pos; // position in symbolic input
++    std::vector<std::string> call_stack;
++    std::vector<uint32_t> possible_solutions;
++
++    void add_possible_solution(uint32_t sol) {
++      possible_solutions.push_back(sol);
++    }
++
++    void clear_possible_solutions() {
++      possible_solutions.clear();
++    }
++
++    EventCharacter(ref<Expr> e, unsigned pos, std::vector<std::string> call_stack):
++      e(e), pos(pos), call_stack(call_stack) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventCharacter\", \"inp_pos\": " << pos << ", \"exec_ctx\": \"" << callStackToString(call_stack) << "\", \"possible_solutions\": [";
++      size_t i = 0;
++      for (uint32_t tok: possible_solutions) {
++        json << tok;
++        if (i != possible_solutions.size()-1) json << ", ";
++        i++;
++      }
++      json << "]}";
++      return json.str();
++    }
++};
++
++class EventRevert: public EventBase {
++  public:
++    int count;
++
++    EventRevert(int count):
++      count(count) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventRevert\", \"count\": " << count << "}";
++      return json.str();
++    }
++};
++
++class EventParseCall: public EventBase {
++  public:
++    std::string ppf;
++
++    EventParseCall(std::string ppf):
++      ppf(ppf) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventParseCall\", \"ppf\": \"" << ppf << "\"}";
++      return json.str();
++    }
++};
++
++class EventLoopEntry: public EventBase {
++  public:
++    llvm::BasicBlock* header_bb;
++    int iter_cnt;
++
++    EventLoopEntry(llvm::BasicBlock* header_bb, int iter_cnt):
++      header_bb(header_bb), iter_cnt(iter_cnt) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventLoopEntry\", \"loop_id\": \"" << header_bb << "\", \"iter_cnt\": " << iter_cnt << "}";
++      return json.str();
++    }
++};
++
++class EventLoopExit: public EventBase {
++  public:
++    llvm::BasicBlock* header_bb;
++
++    EventLoopExit(llvm::BasicBlock* header_bb):
++      header_bb(header_bb) {}
++
++    std::string to_json() const override {
++      std::ostringstream json;
++      json << "{\"event\": \"EventLoopExit\", \"loop_id\": \"" << header_bb << "\"}";      
++      return json.str();
++    }
++};
++
++
++
+ /// @brief ExecutionState representing a path under exploration
+ class ExecutionState {
+ #ifdef KLEE_UNITTEST
+@@ -240,6 +400,30 @@ public:
+   /// @brief Disables forking for this state. Set by user code
+   bool forkDisabled = false;
+ 
++  /// @brief The event stack for all accept, token, loop, ... events.
++  std::vector<EventBase*> eventStack;
++
++  /// @brief The memory object of the cursor pointer.
++  const MemoryObject* mo_cursor;
++
++  /// @brief The offset into the `mo_cursor` where the actual char* cursor is stored [e.g. mo_cursor might point to a struct, or to char** directly]
++  size_t mo_cursor_offset = 0;
++
++  /// @brief The size of the cursor at mo_cursor_offset [usually: sizeof(char*)]
++  size_t mo_cursor_size = 0;
++
++  /// @brief Counts how often "get_next_token" was called.
++  uint64_t token_count = 0;
++
++  /// @brief True if ParserFunctionUnderAnalysis was entered already.
++  bool reachedFUA = false;
++
++  /// @brief highest_input_pos_written - 1 is the last byte accepted, except we're in entry point
++  uint32_t highest_input_pos_written = 0;
++
++  /// @brief Final FUA branch decisions, will be serialized to json.
++  std::vector<bool> finalFunctionPath;
++
+ public:
+ #ifdef KLEE_UNITTEST
+   // provide this function only in the context of unittests
+@@ -262,6 +446,7 @@ public:
+   void popFrame();
+ 
+   void addSymbolic(const MemoryObject *mo, const Array *array);
++  std::vector<std::string> getCallStack(std::string ParserFunctionUnderAnalysis);
+ 
+   void addConstraint(ref<Expr> e);
+   void addCexPreference(const ref<Expr> &cond);
+diff --git a/lib/Core/Executor.cpp b/lib/Core/Executor.cpp
+index 1187654d..538049cc 100644
+--- a/lib/Core/Executor.cpp
++++ b/lib/Core/Executor.cpp
+@@ -319,6 +319,18 @@ cl::opt<unsigned long long> MaxInstructions(
+     cl::init(0),
+     cl::cat(TerminationCat));
+ 
++cl::list<std::string>
++    ParserFunctions("parser-functions",
++                 cl::desc("List of parser functions, e.g.: term."),
++                cl::cat(klee::ModuleCat));
++
++cl::opt<bool> ByteCursor(
++    "byte-cursor",
++    cl::init(true),
++    cl::desc(
++        "Is cursor (as marked by klee_mark_cursor) byte-level (e.g. for json-parse, GetNextToken exploration)? False indicates token-level cursor (e.g. for tinyc syntax exploration). (default=true)"),
++    cl::cat(SeedingCat));
++
+ cl::opt<unsigned>
+     MaxForks("max-forks",
+              cl::desc("Only fork this many times.  Set to -1 to disable (default=-1)"),
+@@ -392,6 +404,32 @@ cl::opt<std::string> TimerInterval(
+     cl::init("1s"),
+     cl::cat(TerminationCat));
+ 
++cl::opt<std::string> ParserFunctionUnderAnalysis(
++    "parser-function-under-analysis",
++    cl::desc("The parser function we are currently analyzing. (default: None)"),
++    cl::init("__no__function__with__this__name"),
++    cl::cat(TerminationCat));
++
++cl::opt<std::string> JsonTraceOutputDir(
++    "json-trace-output-dir",
++    cl::desc("The output directory for json trace files. (default: jsons/)"),
++    cl::init("jsons/"),
++    cl::cat(TerminationCat));
++
++cl::opt<std::string> TokenizationFunction(
++    "tokenization-function",
++    cl::desc("The tokenization function of this subject. (default: None)"),
++    cl::init("__no__function__with__this__name"),
++    cl::cat(TerminationCat));
++
++cl::opt<bool> TokenExplorationMode(
++    "token-exploration-mode",
++    cl::desc("Token exploration mode (for token cursor subjects) (default=false)"),
++    cl::init(false),
++    cl::cat(TerminationCat));
++
++
++
+ 
+ /*** Debugging options ***/
+ 
+@@ -446,6 +484,31 @@ cl::opt<bool> DebugCheckForImpliedValues(
+ 
+ } // namespace
+ 
++
++
++llvm::StringRef getOriginalModuleName(Function &F) {
++  llvm::MDNode *mdNode = F.getMetadata("original_module_name");
++  if (mdNode) {
++    return cast<MDString>(mdNode->getOperand(0))->getString();
++  }
++  return llvm::StringRef("");
++}
++
++bool isUserFunction(Function &F) {
++  llvm::StringRef module_name = getOriginalModuleName(F);
++  if (module_name.endswith(".os"))
++    return false;
++  if (module_name.endswith("_Debug+Asserts.bc"))
++    return false;
++  if (module_name == "")
++    return false;
++  return true;
++}
++
++uint64_t g_json_ctr = 0;
++
++
++
+ // XXX hack
+ extern "C" unsigned dumpStates, dumpPTree;
+ unsigned dumpStates = 0, dumpPTree = 0;
+@@ -512,6 +575,18 @@ Executor::Executor(LLVMContext &ctx, const InterpreterOptions &opts,
+   }
+ }
+ 
++void setFunctionMetadata(llvm::Function &function, llvm::StringRef payload) {
++  llvm::Module *module = function.getParent();
++
++  // Create a new metadata node
++  llvm::LLVMContext &context = module->getContext();
++  llvm::Metadata *metadata = llvm::MDString::get(context, payload);
++
++  // Set the metadata to the function
++  llvm::MDNode *mdNode = llvm::MDNode::get(context, metadata);
++  function.setMetadata("original_module_name", mdNode);
++}
++
+ llvm::Module *
+ Executor::setModule(std::vector<std::unique_ptr<llvm::Module>> &modules,
+                     const ModuleOptions &opts) {
+@@ -532,6 +607,19 @@ Executor::setModule(std::vector<std::unique_ptr<llvm::Module>> &modules,
+     klee_error("Could not load KLEE intrinsic file %s", LibPath.c_str());
+   }
+ 
++  // Iterate over modules, add Metadata to each Function that holds the
++  // original ModuleName, since this information won't be preserved after
++  // linking, but it's helpful to analyze only user application code later, not
++  // libc.
++  for (const std::unique_ptr<llvm::Module>&m : modules) { // const -> no copy of unique ptr
++    if (m) {
++      llvm::StringRef moduleName = m->getName();
++      for (llvm::Function &function : m->getFunctionList()) {
++        setFunctionMetadata(function, moduleName);
++      }
++    }
++  }
++
+   // 1.) Link the modules together
+   while (kmodule->link(modules, opts.EntryPoint)) {
+     // 2.) Apply different instrumentation
+@@ -1120,6 +1208,8 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
+       if (pathWriter) {
+         current.pathOS << "1";
+       }
++      StackFrame &sf = current.stack.back();
++      sf.functionPath.push_back(true);
+     }
+ 
+     return StatePair(&current, nullptr);
+@@ -1128,6 +1218,8 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
+       if (pathWriter) {
+         current.pathOS << "0";
+       }
++      StackFrame &sf = current.stack.back();
++      sf.functionPath.push_back(false);
+     }
+ 
+     return StatePair(nullptr, &current);
+@@ -1193,6 +1285,10 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
+         falseState->symPathOS << "0";
+       }
+     }
++    if (!isInternal) {
++      trueState->stack.back().functionPath.push_back(true);
++      falseState->stack.back().functionPath.push_back(false);
++    }
+ 
+     addConstraint(*trueState, condition);
+     addConstraint(*falseState, Expr::createIsZero(condition));
+@@ -1909,6 +2005,10 @@ void Executor::executeCall(ExecutionState &state, KInstruction *ki, Function *f,
+     // from just an instruction (unlike LLVM).
+     KFunction *kf = kmodule->functionMap[f];
+ 
++    if (f->getName() == ParserFunctionUnderAnalysis || TokenExplorationMode) {
++      state.reachedFUA = true;
++    }
++
+     state.pushFrame(state.prevPC, kf);
+     state.pc = kf->instructions;
+ 
+@@ -2028,8 +2128,106 @@ void Executor::executeCall(ExecutionState &state, KInstruction *ki, Function *f,
+   }
+ }
+ 
++bool Executor::isLoopHeader(BasicBlock* bb) {
++  return kmodule->header_to_exiting_and_exits.count(bb) > 0;
++}
++
++bool Executor::isLoopExitOf(BasicBlock* pot_exit, BasicBlock* header) {
++  std::vector<llvm::BasicBlock*> exit_bbs = kmodule->header_to_exiting_and_exits[header].second;
++  return (std::find(exit_bbs.begin(), exit_bbs.end(), pot_exit) != exit_bbs.end());
++}
++
++EventLoopEntry* Executor::getCurrentLoop(ExecutionState &state) {
++  // This function iterates over the event stack in reverse.
++  // - if LoopEventExit found first: skip all Events until the corresponding LoopEventEntry with iter_cnt = 1 is observed
++  // - else if LoopEventEntry found first: return BasicBlock* of loop header
++  // - else if neither is found: return NULL
++
++  // If needle is != nullptr, this means we're currently skipping things until we find a matching initial EventLoopEntry for a found EventLoopExit.
++  BasicBlock* needle = nullptr;
++
++  for (auto it = state.eventStack.rbegin(); it != state.eventStack.rend(); ++it) {
++    if (EventLoopExit* event_exit = dynamic_cast<EventLoopExit*>(*it)) {
++      if (needle == nullptr) needle = event_exit->header_bb; // Search outmost loop only
++      continue; // E.g. some inner loop terminated, but outer loop could be active still
++    }
++    else if (EventLoopEntry* event_entry = dynamic_cast<EventLoopEntry*>(*it)) {
++      if (needle != nullptr) {
++        if (event_entry->header_bb == needle && event_entry->iter_cnt == 1) {
++          needle = nullptr;
++          continue;
++        }
++      }
++      else {
++        // This is the first found EventLoopEntry, which is not followed by matching EventLoopExit.
++        // a.k.a: The current loop
++        return event_entry;
++      }
++    }
++  }
++
++  // No non-closed loop found.
++  return nullptr;
++}
++
++bool Executor::terminatedDueToLoopBound(BasicBlock *dst, BasicBlock *src, ExecutionState &state) {
++  // <body+header>
++  // print for cases where: exiting jumps to exit; some bb jumps to header (continue)
++  for (auto& pair: kmodule->header_to_exiting_and_exits) {
++    llvm::BasicBlock* header_bb = pair.first;
++    std::vector<llvm::BasicBlock*> exiting_bbs = kmodule->header_to_exiting_and_exits[header_bb].first;
++    std::vector<llvm::BasicBlock*> exit_bbs = kmodule->header_to_exiting_and_exits[header_bb].second;
++    if (std::find(exiting_bbs.begin(), exiting_bbs.end(), src) != exiting_bbs.end()) { // src is some loop's exiting bb
++      if (std::find(exit_bbs.begin(), exit_bbs.end(), dst) != exit_bbs.end()) { // dst is some loop's exit bbs
++        errs() << "Leaving loop body (or header) to exit bb: " << dst << "\n";
++        state.eventStack.push_back(new EventLoopExit(header_bb));
++        break;
++      }
++    }
++  }
++  // </body+header>
++
++
++  // <header>
++  bool terminated = false;
++
++  if (isLoopHeader(dst)) {
++    EventLoopEntry* event_entry = getCurrentLoop(state);
++    if (event_entry == nullptr) { // No ongoing loop
++      // Entering the FUA loop for the first time
++      unsigned cur_loop_iterations = 1;
++      state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
++    } else { // ongoing loop
++      if (event_entry->header_bb == dst) { // Innermost ongoing loop, and we have another iteration of that loop
++        // Entering the FUA loop for the second/third time (e.g. jmp from latch)
++        unsigned cur_loop_iterations = event_entry->iter_cnt + 1;
++
++        if (cur_loop_iterations == 4) {
++          terminated = true;
++          terminateState(state);
++        }
++
++        else {
++          state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
++          assert(cur_loop_iterations <= 4 && "sanity check");
++        }
++      }
++      else {
++        // E.g. We are in outer loop and now entering inner loop
++        unsigned cur_loop_iterations = 1;
++        state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
++      }
++    }
++  }
++  // </header>
++  return terminated;
++}
++
+ void Executor::transferToBasicBlock(BasicBlock *dst, BasicBlock *src, 
+                                     ExecutionState &state) {
++
++  if (terminatedDueToLoopBound(dst, src, state)) return;
++
+   // Note that in general phi nodes can reuse phi values from the same
+   // block but the incoming value is the eval() result *before* the
+   // execution of any phi nodes. this is pathological and doesn't
+@@ -2041,7 +2239,7 @@ void Executor::transferToBasicBlock(BasicBlock *dst, BasicBlock *src,
+   //
+   // With that done we simply set an index in the state so that PHI
+   // instructions know which argument to eval, set the pc, and continue.
+-  
++
+   // XXX this lookup has to go ?
+   KFunction *kf = state.stack.back().kf;
+   unsigned entry = kf->basicBlockEntry[dst];
+@@ -2082,8 +2280,169 @@ Function* Executor::getTargetFunction(Value *calledVal, ExecutionState &state) {
+   }
+ }
+ 
++std::vector<uint32_t> Executor::solveExpr(ExecutionState& state, ref<Expr> e, unsigned max_solutions) {
++  ExecutionState* temp_state = state.branch();
++  std::vector<uint32_t> solutions;
++
++  while (solutions.size() < max_solutions) {
++    ref<ConstantExpr> ce;
++    bool success = solver->getValue(temp_state->constraints, e, ce, temp_state->queryMetaData);
++    assert(success);
++    uint64_t sol = ce->getZExtValue();
++    solutions.push_back((uint32_t)sol);
++    ref<Expr> not_sol = NeExpr::create(e, ConstantExpr::create(sol, e->getWidth()));
++
++    bool res;
++    bool _success = solver->mustBeFalse(temp_state->constraints, not_sol, res, temp_state->queryMetaData);
++    assert(_success);
++    if (res) {
++      // Disallowing the current solution would be impossible => This was the last solution => Stop.
++      break;
++    }
++    temp_state->addConstraint(not_sol); // Forcing new solutions
++  }
++
++  return solutions;
++}
++
++std::vector<uint32_t> Executor::getAllTokenSolutions(ExecutionState& state, std::string token_name) {
++  // Forking the ExecutionState here s.t. `addConstraint` below is not persistent.
++  // E.g., when we serialize the sample token multiple times due to lookaheads/reverts, we want to get the full
++  // solution set each time.
++
++  ExecutionState* temp_state = state.branch();
++
++  std::vector<uint32_t> solutions;
++
++  solver->setTimeout(coreSolverTimeout);
++  ConstraintSet extendedConstraints(temp_state->constraints);
++  ConstraintManager cm(extendedConstraints);
++
++  MemoryMap::iterator mi = temp_state->addressSpace.objects.begin();
++  MemoryMap::iterator me = temp_state->addressSpace.objects.end();
++
++  while (mi != me) {
++    const MemoryObject* mo = mi->first;
++    ref<ObjectState> os = mi->second;
++    if (mo->name == token_name) {
++      errs() << "found mo for " << token_name << "\n";
++      while (true) {
++        ref<Expr> e_tok = os->read(ConstantExpr::create(0, Expr::Int32), 8*mo->size);
++        ref<ConstantExpr> ce_sol;
++        bool success = solver->getValue(temp_state->constraints, e_tok, ce_sol, temp_state->queryMetaData);
++        assert(success);
++        uint32_t sol = (uint32_t)ce_sol->getZExtValue();
++        errs() << "Executor::getAllTokenSolutions found a solution: " << sol << "\n";
++
++        solutions.push_back(sol);
++        ref<Expr> not_sol = NeExpr::create(e_tok, ConstantExpr::create(sol, e_tok->getWidth()));
++
++        bool res;
++        bool _success = solver->mustBeFalse(temp_state->constraints, not_sol, res, temp_state->queryMetaData);
++        assert(_success);
++        if (res) {
++          // Disallowing the current solution would be impossible => This was the last solution => Stop.
++          break;
++        }
++
++        temp_state->addConstraint(not_sol); // Forcing new solutions
++      }
++
++      break;
++    }
++    ++mi;
++  }
++
++  solver->setTimeout(time::Span());
++
++  errs() << "Executor::getAllTokenSolutions returned.\n";
++  return solutions;
++}
++
++void Executor::pruneEventCharacters(ExecutionState &state) {
++  std::vector<EventBase*> newEventStack;
++  std::set<unsigned> seen_pos;
++
++  for (size_t i = state.eventStack.size(); i > 0; i--) {
++    EventBase* event = state.eventStack[i-1];
++    if (EventCharacter* event_character = dynamic_cast<EventCharacter*>(event)) {
++      unsigned pos = event_character->pos;
++      if (seen_pos.find(pos) == seen_pos.end()) { // not seen yet
++        // add to front (because we iterate in reverse), so final order is as before.
++        newEventStack.insert(newEventStack.begin(), event);
++        seen_pos.insert(pos);
++      }
++    }
++    else {
++      newEventStack.insert(newEventStack.begin(), event);
++    }
++  }
++  state.eventStack = newEventStack;
++}
++
++void Executor::serialize_eventstack_to_json(ExecutionState &state, bool print) {
++  pruneEventCharacters(state);
++
++  bool first = true;
++  std::ostringstream json;
++
++  json << "{\"functionpath\": \"";
++  for (bool b: state.finalFunctionPath) {
++    if (b) json << "1";
++    else json << "0";
++  }
++  json << "\",\n";
++
++  json << "\"events\": [\n";
++  if (print) errs() << "Serializing eventstack to json...\n";
++  for (size_t i = 0; i < state.eventStack.size(); i++) {
++    EventBase* event = state.eventStack[i];
++    bool skip = false;
++    if (print) errs() << "Event " << i << ":\n";
++    if (EventCharacter* event_character = dynamic_cast<EventCharacter*>(event)) {
++      if (event_character->pos < state.highest_input_pos_written) {
++        event_character->clear_possible_solutions();
++        std::vector<uint32_t> solutions = solveExpr(state, event_character->e, 256);
++        for (uint32_t sol: solutions) {
++          event_character->add_possible_solution(sol);
++        }
++      } else skip = true;
++    }
++    else if (EventToken* event_token = dynamic_cast<EventToken*>(event)) {
++      event_token->clear_possible_tokens();
++      std::string sym_var = "tok_" + std::to_string(event_token->id);
++      std::vector<uint32_t> solutions = getAllTokenSolutions(state, sym_var);
++      for (uint32_t sol: solutions) {
++        event_token->add_possible_token(sol);
++      }
++    }
++    if (!skip) {
++      if (!first) {
++        json << ",";
++      } else {
++        first = false;
++      }
++      json << "\t" << event->to_json();
++      json << "\n";
++
++      if (print) errs() << "\t" << event->to_json() << "\n";
++    }
++  }
++
++  json << "]}\n";
++
++  // Serialize json
++  //std::ofstream outputFile("jsons/" + ParserFunctionUnderAnalysis + "-" + std::to_string(g_json_ctr++) +".json");
++  std::ofstream outputFile(JsonTraceOutputDir + ParserFunctionUnderAnalysis + "-" + std::to_string(g_json_ctr++) +".json");
++  if (outputFile.is_open()) {
++    outputFile << json.str();
++    outputFile.close();
++  }
++}
++
+ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+   Instruction *i = ki->inst;
++
+   switch (i->getOpcode()) {
+     // Control flow
+   case Instruction::Ret: {
+@@ -2092,6 +2451,25 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+     Instruction *caller = kcaller ? kcaller->inst : nullptr;
+     bool isVoidReturn = (ri->getNumOperands() == 0);
+     ref<Expr> result = ConstantExpr::alloc(0, Expr::Bool);
++
++    if (ri && ri->getFunction() && (ri->getFunction()->getName() == ("__user_" + entrypoint))) {
++      // We wait for the KLEE WRAPPER function (kw_) to return, which implements the 
++      // function-level syntax error oracle (and in fact does not return if it detects
++      // a syntax error).
++      // The "__user_" prefix is added by KLEE.
++      errs() << "<FUA returned>\n";
++      serialize_eventstack_to_json(state, false);
++      errs() << "</FUA returned>\n";
++    }
++
++    if (ri && ri->getFunction() && (ri->getFunction()->getName() == ParserFunctionUnderAnalysis)) {
++      // The parser function under analysis returns to klee wrapper.
++      // We store the `functionPath` of this function.
++      assert(state.finalFunctionPath.empty());
++      StackFrame &sf = state.stack.back();
++      state.finalFunctionPath = sf.functionPath;
++    }
++
+     
+     if (!isVoidReturn) {
+       result = eval(ki, 0, state).value;
+@@ -2201,10 +2579,12 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+       if (statsTracker && state.stack.back().kf->trackCoverage)
+         statsTracker->markBranchVisited(branches.first, branches.second);
+ 
+-      if (branches.first)
++      if (branches.first) {
+         transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
+-      if (branches.second)
++      }
++      if (branches.second) {
+         transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
++      }
+     }
+     break;
+   }
+@@ -2394,8 +2774,9 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+                                                ie = bbOrder.end();
+            it != ie; ++it) {
+         ExecutionState *es = *bit;
+-        if (es)
++        if (es) {
+           transferToBasicBlock(*it, bb, *es);
++        }
+         ++bit;
+       }
+     }
+@@ -2427,6 +2808,49 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+     for (unsigned j=0; j<numArgs; ++j)
+       arguments.push_back(eval(ki, j+1, state).value);
+ 
++    for (const auto &pf : ParserFunctions) {
++      if (f && f->getName() == pf) {
++        auto caller_function = i->getFunction()->getName().str();
++        if (caller_function == "__klee_posix_wrapped_main") {
++          // This is the entrypoint initially calling the FUA => Do not redirect or output.
++          break;
++        }
++        if (caller_function != ParserFunctionUnderAnalysis) {
++          errs() << "Error: " << i->getFunction()->getName() << " called " << pf << "\n";
++          klee_error("Non-FUA called PPF");
++        }
++
++        state.eventStack.push_back(new EventParseCall(pf));
++
++        // Detour parser functions to corresponding symbolic proxy
++        for (auto &kf: kmodule->functions) {
++          // errs() << "All functions: " << kf->function->getName().str() << "\n";
++          if (kf->function->getName().str() == "sym_"+f->getName().str()) {
++            errs() << "Redirecting call to sym_" << f->getName() << "\n";
++            f = kf->function;
++            break;
++          }
++        }
++        break;
++      }
++    }
++
++    // We push EventToken and do the increment on handleGetNextTokenCtr now.
++
++    // Detour `GetNextToken` function
++    if (!ByteCursor) {
++      if (f && f->getName().str() == TokenizationFunction) {
++        for (auto &kf: kmodule->functions) {
++          if (kf->function->getName().str() == "sym_"+f->getName().str()) {
++            errs() << "Redirecting call to sym. tokenization function sym_" << f->getName() << "\n";
++            f = kf->function;
++            break;
++          }
++        }
++      }
++    }
++
++
+     if (auto* asmValue = dyn_cast<InlineAsm>(fp)) { //TODO: move to `executeCall`
+       if (ExternalCalls != ExternalCallPolicy::None) {
+         KInlineAsm callable(asmValue);
+@@ -2779,6 +3203,7 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
+     if (kgepi->offset)
+       base = AddExpr::create(base,
+                              Expr::createPointer(kgepi->offset));
++    
+     bindLocal(ki, state, base);
+     break;
+   }
+@@ -4230,6 +4655,79 @@ void Executor::executeMemoryOperation(ExecutionState &state,
+           terminateStateOnError(state, "memory error: object read only",
+                                 StateTerminationType::ReadOnly);
+         } else {
++          if (!ByteCursor) { // Token Cursor
++            if (mo == state.mo_cursor) {
++              if (isa<ConstantExpr>(offset) && cast<ConstantExpr>(offset)->getZExtValue() == state.mo_cursor_offset) {
++                // new value:
++                std::vector<const Array *> new_objects;
++                findSymbolicObjects(value, new_objects);
++                // Some parsers are not well behaved in a sense that they write a constant (such as ERROR) to the token cursor 
++                // from a parse function, i.e. not via the singular tokenization function. In this case the written value is not
++                // a symbolic object, so new_objects.size() == 0. We catch this case here.
++                if (new_objects.size() == 0) {
++                  errs() << "Write concrete object to token cursor, ignoring\n";
++                } else {
++                  assert(new_objects.size() == 1);
++                  errs() << "new cursor: " << new_objects[0]->name << "\n";
++
++                  // old value:
++                  std::vector<const Array *> old_objects;
++                  ref<Expr> e_old_value = os->read(ConstantExpr::create(state.mo_cursor_offset, Expr::Int32), 8*state.mo_cursor_size);
++                  findSymbolicObjects(e_old_value, old_objects);
++                  assert(old_objects.size() <= 1);
++                  if (old_objects.size() == 0) errs() << "old cursor: None\n";
++                  else errs() << "old cursor: " << old_objects[0]->name << "\n";
++
++                  if (old_objects.size() == 1 && new_objects.size() == 1) {
++                    std::string old_tok_var = old_objects[0]->name;
++                    std::string new_tok_var = new_objects[0]->name;
++                    std::string prefix = "tok_";
++                    assert(old_tok_var.substr(0, prefix.length()) == prefix);
++                    assert(new_tok_var.substr(0, prefix.length()) == prefix);
++                    int old_tok_ctr = std::stoi(old_tok_var.substr(prefix.length()));
++                    int new_tok_ctr = std::stoi(new_tok_var.substr(prefix.length()));
++                    errs() << "old_tok_ctr: " << old_tok_ctr << " new_tok_ctr: " << new_tok_ctr << "\n";
++                    // TODO: Maybe push EventToken here, which we currently do in handleGetNextTokenCtr.
++                    if (new_tok_ctr == old_tok_ctr+1) { /*OK*/ }
++                    else if (new_tok_ctr == old_tok_ctr) { /*OK*/ }
++                    else if (new_tok_ctr < old_tok_ctr) {
++                      state.eventStack.push_back(new EventRevert(old_tok_ctr - new_tok_ctr));
++                      state.token_count = new_tok_ctr;
++                    }
++                    else {
++                      errs() << "not OK\n";
++                      assert(false);
++                    }
++                  }
++                }
++              }
++            }
++          } else { // Byte Cursor
++            ObjectPair op;
++            if (ConstantExpr *CE = dyn_cast<ConstantExpr>(value)) {
++              // KLEE will fail an assertion in getZExtValue for width > 64 bit
++              // Pointers are always <= 64 bit, so this is fine.
++              if (CE->getWidth() <= 64) {
++                if (state.addressSpace.resolveOne(CE, op)) {
++                  const MemoryObject *mo = op.first;
++                  const ObjectState *os = op.second;
++                  ref<Expr> offset_expr = mo->getOffsetExpr(CE);
++                  size_t offset = cast<ConstantExpr>(offset_expr)->getZExtValue();
++                  if (state.reachedFUA && mo->name == "input_str") { // Hard coded name in klee wrappers
++                    // If we *write* (currently: for the first time) an the addr of inp[i+1], we consider this an access to inp[i].
++                    if (offset > 0) {
++                      if (state.highest_input_pos_written < offset) {
++                        ref<Expr> e = os->read8(offset-1);
++                        state.eventStack.push_back(new EventCharacter(e, offset-1, state.getCallStack(ParserFunctionUnderAnalysis)));
++                      }
++                    }
++                    state.highest_input_pos_written = std::max(state.highest_input_pos_written, (uint32_t)offset);
++                  }
++                }
++              }
++            }
++          }
++
+           ObjectState *wos = state.addressSpace.getWriteable(mo, os);
+           wos->write(offset, value);
+         }          
+@@ -4382,6 +4880,8 @@ void Executor::runFunctionAsMain(Function *f,
+ 				 char **envp) {
+   std::vector<ref<Expr> > arguments;
+ 
++  entrypoint = f->getName().str();
++
+   // force deterministic initialization of memory objects
+   srand(1);
+   srandom(1);
+diff --git a/lib/Core/Executor.h b/lib/Core/Executor.h
+index 279d8bee..48115eff 100644
+--- a/lib/Core/Executor.h
++++ b/lib/Core/Executor.h
+@@ -119,6 +119,8 @@ private:
+   TimerGroup timers;
+   std::unique_ptr<PTree> processTree;
+ 
++  std::string entrypoint;
++
+   /// Used to track states that have been added during the current
+   /// instructions step. 
+   /// \invariant \ref addedStates is a subset of \ref states. 
+@@ -215,6 +217,15 @@ private:
+   llvm::Function* getTargetFunction(llvm::Value *calledVal,
+                                     ExecutionState &state);
+   
++  bool terminatedDueToLoopBound(llvm::BasicBlock *dst, llvm::BasicBlock *src, ExecutionState &state);
++  bool isLoopHeader(llvm::BasicBlock* bb);
++  bool isLoopExitOf(llvm::BasicBlock* pot_exit, llvm::BasicBlock* header);
++  EventLoopEntry* getCurrentLoop(ExecutionState &state);
++  std::vector<uint32_t> solveExpr(ExecutionState& state, ref<Expr> e, unsigned max_solutions);
++  std::vector<uint32_t> getAllTokenSolutions(ExecutionState& state, std::string token_name);
++  void serialize_eventstack_to_json(ExecutionState &state, bool print);
++  void pruneEventCharacters(ExecutionState &state);
++
+   void executeInstruction(ExecutionState &state, KInstruction *ki);
+ 
+   void run(ExecutionState &initialState);
+@@ -313,6 +324,7 @@ private:
+                    llvm::Function *f,
+                    std::vector< ref<Expr> > &arguments);
+                    
++  
+   // do address resolution / object binding / out of bounds checking
+   // and perform the operation
+   void executeMemoryOperation(ExecutionState &state,
+diff --git a/lib/Core/SpecialFunctionHandler.cpp b/lib/Core/SpecialFunctionHandler.cpp
+index f4b09f36..c8d0251b 100644
+--- a/lib/Core/SpecialFunctionHandler.cpp
++++ b/lib/Core/SpecialFunctionHandler.cpp
+@@ -102,6 +102,9 @@ static SpecialFunctionHandler::HandlerInfo handlerInfo[] = {
+ #endif
+   add("klee_is_symbolic", handleIsSymbolic, true),
+   add("klee_make_symbolic", handleMakeSymbolic, false),
++  add("klee_mark_cursor", handleMarkCursor, false),
++  add("klee_pass_token", handlePassToken, false),
++  add("klee_get_next_token_ctr", handleGetNextTokenCtr, true),
+   add("klee_mark_global", handleMarkGlobal, false),
+   add("klee_open_merge", handleOpenMerge, false),
+   add("klee_close_merge", handleCloseMerge, false),
+@@ -855,6 +858,59 @@ void SpecialFunctionHandler::handleMakeSymbolic(ExecutionState &state,
+   }
+ }
+ 
++void SpecialFunctionHandler::handleMarkCursor(ExecutionState &state,
++                                            KInstruction *target,
++                                            std::vector<ref<Expr> > &arguments) {
++  assert(arguments.size()==2 &&
++         "invalid number of arguments to klee_mark_cursor. Usage: klee_mark_cursor(char** pCursor, size_t [usually sizeof(char*)])");
++
++  errs() << "klee_mark_cursor called on " << arguments[0] << "\n";
++
++  ref<ConstantExpr> address = cast<ConstantExpr>(arguments[0]);
++  ObjectPair op;
++  if (!state.addressSpace.resolveOne(address, op)) {
++    errs() << "!resolveOne\n";
++    assert(false);
++  }
++
++  size_t cursor_size = cast<ConstantExpr>(arguments[1])->getZExtValue();
++
++  const MemoryObject *mo = op.first;
++  // const ObjectState *os = op.second;
++  auto relativeOffset = mo->getOffsetExpr(address);
++  // the relativeOffset must be concrete as the address is concrete
++  size_t offset = cast<ConstantExpr>(relativeOffset)->getZExtValue();
++  state.mo_cursor = mo;
++  state.mo_cursor_offset = offset;
++  state.mo_cursor_size = cursor_size;
++  errs() << "klee_mark_cursor found object: " << mo->name << " at " << mo->address << " size=" << mo->size << "\n";
++  errs() << "klee_mark_cursor offset: " << state.mo_cursor_offset << " size " << state.mo_cursor_size << "\n";
++}
++
++void SpecialFunctionHandler::handlePassToken(ExecutionState &state,
++                                            KInstruction *target,
++                                            std::vector<ref<Expr> > &arguments) {
++  assert(arguments.size()==1 &&
++         "invalid number of arguments to klee_pass_token. Usage: klee_pass_token(int token)");
++
++  errs() << "klee_pass_token called on " << arguments[0] << "\n";
++  ref<ConstantExpr> token_id = cast<ConstantExpr>(arguments[0]);
++  state.eventStack.push_back(new EventPassToken(token_id->getZExtValue()));
++}
++
++
++// get_next_token functions must call this once.
++void SpecialFunctionHandler::handleGetNextTokenCtr(ExecutionState &state,
++                                            KInstruction *target,
++                                            std::vector<ref<Expr> > &arguments) {
++  assert(arguments.size()==0 &&
++         "invalid number of arguments to klee_get_next_token_ctr");
++  state.token_count++;
++  state.eventStack.push_back(new EventToken(state.token_count));
++  executor.bindLocal(target, state, ConstantExpr::create(state.token_count, Expr::Int32));
++}
++
++
+ void SpecialFunctionHandler::handleMarkGlobal(ExecutionState &state,
+                                               KInstruction *target,
+                                               std::vector<ref<Expr> > &arguments) {
+diff --git a/lib/Core/SpecialFunctionHandler.h b/lib/Core/SpecialFunctionHandler.h
+index 9487fdf5..7339cb8e 100644
+--- a/lib/Core/SpecialFunctionHandler.h
++++ b/lib/Core/SpecialFunctionHandler.h
+@@ -125,6 +125,10 @@ namespace klee {
+     HANDLER(handleMakeSymbolic);
+     HANDLER(handleMalloc);
+     HANDLER(handleMemalign);
++    HANDLER(handleMarkCursor);
++    HANDLER(handlePassToken);
++    HANDLER(handleGetNextTokenCtr);
++    HANDLER(handleGetNextToken);
+     HANDLER(handleMarkGlobal);
+     HANDLER(handleOpenMerge);
+     HANDLER(handleCloseMerge);
+diff --git a/lib/Expr/ExprUtil.cpp b/lib/Expr/ExprUtil.cpp
+index 3819e3a2..b3655788 100644
+--- a/lib/Expr/ExprUtil.cpp
++++ b/lib/Expr/ExprUtil.cpp
+@@ -118,8 +118,60 @@ ExprVisitor::Action ConstantArrayFinder::visitRead(const ReadExpr &re) {
+ 
+   return Action::doChildren();
+ }
++
++class SymbolicObjectIndexFinder : public ExprVisitor {
++protected:
++  Action visitRead(const ReadExpr &re) {
++    const UpdateList &ul = re.updates;
++
++    // XXX should we memo better than what ExprVisitor is doing for us?
++    for (const auto *un = ul.head.get(); un; un = un->next.get()) {
++      visit(un->index);
++      visit(un->value);
++    }
++
++    if (ul.root->isSymbolicArray()) {
++      //if (results.insert(ul.root).second)
++      objects.push_back(ul.root);
++      updatelists.push_back(ul);
++      indices.push_back(re.index);
++    }
++
++    return Action::doChildren();
++  }
++
++public:
++  std::set<const Array*> results;
++  std::vector<const Array*> &objects;
++  std::vector<UpdateList> &updatelists;
++  std::vector<ref<Expr>> &indices;
++
++  SymbolicObjectIndexFinder(std::vector<const Array*> &_objects, std::vector<UpdateList> &_updatelists, std::vector<ref<Expr>> &_indices)
++    : objects(_objects), updatelists(_updatelists), indices(_indices) {}
++};
++
++
++}
++
++template<typename InputIterator>
++void klee::findSymbolicObjectIndices(InputIterator begin, 
++                               InputIterator end,
++                               std::vector<const Array*> &results_arrays,
++                               std::vector<UpdateList> &updatelists,
++                               std::vector<ref<Expr>> &indices) {
++  SymbolicObjectIndexFinder of(results_arrays, updatelists, indices);
++  for (; begin!=end; ++begin)
++    of.visit(*begin);
++}
++
++void klee::findSymbolicObjectIndices(ref<Expr> e,
++                               std::vector<const Array*> &results_arrays,
++                               std::vector<UpdateList> &updatelists,
++                               std::vector<ref<Expr>> &indices) {
++  findSymbolicObjectIndices(&e, &e+1, results_arrays, updatelists, indices);
+ }
+ 
++
+ template<typename InputIterator>
+ void klee::findSymbolicObjects(InputIterator begin, 
+                                InputIterator end,
+diff --git a/lib/Module/CMakeLists.txt b/lib/Module/CMakeLists.txt
+index 6c2a24b3..b9caf3d7 100644
+--- a/lib/Module/CMakeLists.txt
++++ b/lib/Module/CMakeLists.txt
+@@ -20,6 +20,7 @@ set(KLEE_MODULE_COMPONENT_SRCS
+   OptNone.cpp
+   PhiCleaner.cpp
+   RaiseAsm.cpp
++  ParserLoopAnalysis.cpp
+ )
+ 
+ klee_add_component(kleeModule
+diff --git a/lib/Module/KModule.cpp b/lib/Module/KModule.cpp
+index 2e96c68a..b5a77fc0 100644
+--- a/lib/Module/KModule.cpp
++++ b/lib/Module/KModule.cpp
+@@ -50,6 +50,10 @@ namespace klee {
+ cl::OptionCategory
+     ModuleCat("Module-related options",
+               "These options affect the compile-time processing of the code.");
++
++cl::OptionCategory
++    StaticGrammarMiningCat("Static grammar mining-related options",
++              "These options affect static analysis related to grammar mining.");
+ }
+ 
+ namespace {
+@@ -98,6 +102,13 @@ namespace {
+                              cl::desc("Allow optimization of functions that "
+                                       "contain KLEE calls (default=true)"),
+                              cl::init(true), cl::cat(ModuleCat));
++
++cl::opt<bool> StaticGrammarMining(
++    "static-grammar-mining",
++    cl::desc(
++        "Static Grammar Mining mode, runs ReachbleParseFunctions pass (default=false)"), // to be used in conjunction with --entrypoint (default=false)"),
++    cl::init(false),
++    cl::cat(StaticGrammarMiningCat));
+ }
+ 
+ /***/
+@@ -278,7 +289,15 @@ void KModule::optimiseAndPrepare(
+   pm3.add(createScalarizerPass());
+   pm3.add(new PhiCleanerPass());
+   pm3.add(new FunctionAliasPass());
++
++  if (StaticGrammarMining) pm3.add(createUnifyLoopExitsPass()); // Required s.t. all loops have one exit
++  if (StaticGrammarMining) pm3.add(new ParserLoopAnalysis(header_to_exiting_and_exits));
++
+   pm3.run(*module);
++
++  for (const auto &pair: header_to_exiting_and_exits) {
++    errs() << "Extracted loop header: " << pair.first << "\n";
++  }
+ }
+ 
+ void KModule::manifest(InterpreterHandler *ih, bool forceSourceOutput) {
+diff --git a/lib/Module/ParserLoopAnalysis.cpp b/lib/Module/ParserLoopAnalysis.cpp
+new file mode 100644
+index 00000000..b91601fe
+--- /dev/null
++++ b/lib/Module/ParserLoopAnalysis.cpp
+@@ -0,0 +1,171 @@
++//===-- ParserLoopAnalysis.cpp
++//-------------------------------------------------------===//
++
++#include "Passes.h"
++
++#include "klee/Core/Interpreter.h"
++//#include "klee/Config/Version.h"
++#include "llvm/Pass.h"
++//#include "llvm/PassAnalysisSupport.h"
++#include "llvm/IR/Dominators.h"
++
++#include "llvm/ADT/SmallPtrSet.h"
++#include "llvm/Analysis/TargetLibraryInfo.h"
++#include "llvm/Analysis/LoopInfo.h"
++#include "llvm/IR/BasicBlock.h"
++#include "llvm/IR/CFG.h"
++// #include "llvm/IR/CallSite.h"
++#include "llvm/IR/Function.h"
++#include "llvm/IR/Instruction.h"
++#include "llvm/IR/Module.h"
++#include "llvm/IR/IntrinsicInst.h"
++#include "llvm/IR/DebugInfoMetadata.h"
++#include "llvm/Support/CommandLine.h"
++#include "llvm/Support/raw_ostream.h"
++
++
++#include <cassert>
++#include <fstream>
++#include <iomanip>
++#include <map>
++#include <set>
++#include <vector>
++#include <regex>
++
++using namespace llvm;
++using namespace klee;
++
++cl::OptionCategory
++    StaticGrammarMiningCat("Static grammar mining-related options",
++              "These options affect static analysis related to grammar mining.");
++
++namespace {
++    cl::opt<std::string>
++        FUA("llvm-pass-parser-function-under-analysis",
++                cl::desc("Function name of the parser function under analysis point (default: None)."),
++                cl::init("__no__function__with__this__name"),
++                cl::cat(StaticGrammarMiningCat));
++}
++
++
++namespace klee {
++
++char ParserLoopAnalysis::ID;
++
++////////////////////////////
++/////////  Helpers /////////
++////////////////////////////
++
++std::string get_source_filename(Function& F) {
++    SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;
++    F.getAllMetadata(MDs);
++    for (auto &MD : MDs) {
++        if (MDNode *N = MD.second) {
++            if (auto *subProgram = dyn_cast<DISubprogram>(N)) {
++                return subProgram->getFilename().str();
++            }
++        }
++    }
++    return "";
++}
++
++llvm::StringRef getOriginalModuleName(Function &F) {
++  llvm::MDNode *mdNode = F.getMetadata("original_module_name");
++  if (mdNode) {
++    return cast<MDString>(mdNode->getOperand(0))->getString();
++  }
++  return llvm::StringRef("");
++}
++
++bool isUserFunction(Function &F) {
++  llvm::StringRef module_name = getOriginalModuleName(F);
++  if (module_name.endswith(".os"))
++    return false;
++  if (module_name.endswith("_Debug+Asserts.bc"))
++    return false;
++  if (module_name == "")
++    return false;
++  return true;
++}
++
++////////////////////////////
++/////////  Passes /////////
++////////////////////////////
++
++
++void ParserLoopAnalysis::getAnalysisUsage(
++    llvm::AnalysisUsage &AU) const {
++  AU.addRequired<llvm::LoopInfoWrapperPass>();
++}
++
++bool ParserLoopAnalysis::runOnFunction(Function &F) {
++    if (FUA == "__no__function__with__this__name") return false;
++    if (F.getName() != FUA) return false;
++
++    errs() << "ParserLoopAnalysis called." << "\n";
++
++    LoopInfo &LI = getAnalysis<llvm::LoopInfoWrapperPass>().getLoopInfo();
++
++    std::vector<Loop*> queue;
++    for (Loop* L: LI) {
++      queue.push_back(L);
++    }
++
++    while (!queue.empty()) {
++      Loop* L = queue.front();
++      queue.erase(queue.begin()); // Pop first element
++      for (auto it = L->getSubLoops().begin(); it !=  L->getSubLoops().end(); ++it) {
++        queue.push_back(*it);
++      }
++
++      errs() << "Processing a loop in function " << F.getName() << ":\n";
++      BasicBlock* header = L->getHeader();
++      errs() << "Header: " << *header << "\n";
++      
++      errs() << "Exiting blocks for loop:\n";
++      SmallVector<BasicBlock *, 8> ExitingBlocks;
++      L->getExitingBlocks(ExitingBlocks);
++
++      int i=0;
++      for (BasicBlock *BB : ExitingBlocks) {
++        errs() << "Exiting BB" << i << ":\n";
++        BB->print(errs());
++        errs() << "\n";
++        errs() << "Terminator: " << *(BB->getTerminator()) << "\n";
++        i++;
++      }
++
++      errs() << "Exit blocks for loop (outside):\n";
++      SmallVector<BasicBlock *, 8> ExitBlocks;
++      L->getExitBlocks(ExitBlocks);
++      // NOTE: There may be duplicates in ExitBlocks.
++      // It's just all the successor blocks of all branches that may exit the loop.
++      // So if we have multiple `break;` statements, for example, these will be duplicated.
++      i = 0;
++      for (BasicBlock *BB : ExitBlocks) {
++        errs() << "Exit BB" << i << ":\n";
++        BB->print(errs());
++        errs() << "\n";
++        errs() << "Terminator: " << *(BB->getTerminator()) << "\n";
++        i++;
++      }
++
++      std::vector<BasicBlock*> UniqueExitingBlocks(ExitingBlocks.begin(), ExitingBlocks.end()); // always unique
++      std::vector<BasicBlock*> UniqueExitBlocks;
++      for (BasicBlock* BB: ExitBlocks) {
++        if (std::find(UniqueExitBlocks.begin(), UniqueExitBlocks.end(), BB) == UniqueExitBlocks.end()) {
++          UniqueExitBlocks.push_back(BB);
++        }
++      }
++
++      assert(UniqueExitBlocks.size() == 1 && "Loops must have exactly 1 exit BB currently.");
++
++      header_to_exiting_and_exits[header] = std::make_pair(UniqueExitingBlocks, UniqueExitBlocks);
++    }
++
++    return false;
++}
++
++
++
++} // namespace klee
+\ No newline at end of file
+diff --git a/lib/Module/Passes.h b/lib/Module/Passes.h
+index 3eb43ec3..e041cb0e 100644
+--- a/lib/Module/Passes.h
++++ b/lib/Module/Passes.h
+@@ -192,6 +192,16 @@ public:
+   OptNonePass() : llvm::ModulePass(ID) {}
+   bool runOnModule(llvm::Module &M) override;
+ };
++
++class ParserLoopAnalysis : public llvm::FunctionPass {
++public:
++  static char ID;
++  std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> &header_to_exiting_and_exits; // map header bb to exiting, exit bbs // OUTPUT
++  ParserLoopAnalysis(std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> &T) : llvm::FunctionPass(ID), header_to_exiting_and_exits(T) {}
++  void getAnalysisUsage(llvm::AnalysisUsage &AU) const;
++  bool runOnFunction(llvm::Function &F) override;
++};
++
+ } // namespace klee
+ 
+ #endif /* KLEE_PASSES_H */
+diff --git a/tools/klee/main.cpp b/tools/klee/main.cpp
+index 7d938ab2..244da123 100644
+--- a/tools/klee/main.cpp
++++ b/tools/klee/main.cpp
+@@ -768,7 +768,11 @@ static const char *modelledExternals[] = {
+   "klee_get_obj_size",
+   "klee_is_symbolic",
+   "klee_make_symbolic",
++  "klee_pass_cursor",
++  "klee_pass_token",
++  "klee_get_next_token_ctr",
+   "klee_mark_global",
++  "klee_mark_cursor",
+   "klee_open_merge",
+   "klee_close_merge",
+   "klee_prefer_cex",
diff --git a/lib/Core/ExecutionState.cpp b/lib/Core/ExecutionState.cpp
index 5231f7fb..750b4a4b 100644
--- a/lib/Core/ExecutionState.cpp
+++ b/lib/Core/ExecutionState.cpp
@@ -58,7 +58,8 @@ StackFrame::StackFrame(const StackFrame &s)
     callPathNode(s.callPathNode),
     allocas(s.allocas),
     minDistToUncoveredOnReturn(s.minDistToUncoveredOnReturn),
-    varargs(s.varargs) {
+    varargs(s.varargs),
+    functionPath(s.functionPath) {
   locals = new Cell[s.kf->numRegisters];
   for (unsigned i=0; i<s.kf->numRegisters; i++)
     locals[i] = s.locals[i];
@@ -105,7 +106,16 @@ ExecutionState::ExecutionState(const ExecutionState& state):
                              ? state.unwindingInformation->clone()
                              : nullptr),
     coveredNew(state.coveredNew),
-    forkDisabled(state.forkDisabled) {
+    forkDisabled(state.forkDisabled),
+    eventStack(state.eventStack), // added
+    mo_cursor(state.mo_cursor), // added
+    mo_cursor_offset(state.mo_cursor_offset), // added
+    mo_cursor_size(state.mo_cursor_size), // added
+    token_count(state.token_count), // added
+    reachedFUA(state.reachedFUA), // added
+    highest_input_pos_written(state.highest_input_pos_written), // added
+    finalFunctionPath(state.finalFunctionPath) // added
+    {
   for (const auto &cur_mergehandler: openMergeStack)
     cur_mergehandler->addOpenState(this);
 }
@@ -136,6 +146,39 @@ void ExecutionState::addSymbolic(const MemoryObject *mo, const Array *array) {
   symbolics.emplace_back(ref<const MemoryObject>(mo), array);
 }
 
+std::vector<std::string> ExecutionState::getCallStack(std::string ParserFunctionUnderAnalysis) {
+  std::vector<std::string> callstack;
+  StackFrame& sf_top = stack.back();
+
+  for (const StackFrame &sf : stack) {
+    if (sf.kf->function->getName().str() == ParserFunctionUnderAnalysis) {
+      // We add the function-local path of the FUA to the context.
+      // We only ever call the current function from the FUA, or a tokenization function called by the FUA.
+      // If we're in a tokenization function, we still use only the FUA path.
+      // The reason: Only in FUA, loops are bounded.
+      std::string s_functionPath;
+      for (bool b: sf.functionPath) {
+        if (b) s_functionPath += "1";
+        else s_functionPath += "0";
+      }
+      callstack.push_back(s_functionPath);
+      break;
+    }
+  }
+  
+  if (sf_top.kf->function->getName().str() == ParserFunctionUnderAnalysis) {
+    // Add current instruction in current function (we need both: functionPath and this)
+    Instruction *cur_inst = prevPC ? prevPC->inst : nullptr;
+    std::string s;
+    llvm::raw_string_ostream llvm_s(s);
+    llvm_s << cur_inst;
+    callstack.push_back(llvm_s.str()); 
+  }
+
+  return callstack;
+}
+
+
 /**/
 
 llvm::raw_ostream &klee::operator<<(llvm::raw_ostream &os, const MemoryMap &mm) {
diff --git a/lib/Core/ExecutionState.h b/lib/Core/ExecutionState.h
index 49e232dc..52c58c2e 100644
--- a/lib/Core/ExecutionState.h
+++ b/lib/Core/ExecutionState.h
@@ -21,6 +21,8 @@
 #include "klee/Solver/Solver.h"
 #include "klee/System/Time.h"
 
+#include "llvm/IR/BasicBlock.h"
+
 #include <map>
 #include <memory>
 #include <set>
@@ -60,6 +62,8 @@ struct StackFrame {
   // of intrinsic lowering.
   MemoryObject *varargs;
 
+  std::vector<bool> functionPath;
+
   StackFrame(KInstIterator caller, KFunction *kf);
   StackFrame(const StackFrame &s);
   ~StackFrame();
@@ -143,6 +147,162 @@ struct CleanupPhaseUnwindingInformation : public UnwindingInformation {
   }
 };
 
+
+class EventBase {
+  public:
+    virtual ~EventBase() = default;
+    virtual std::string to_json() const = 0;
+    static std::string callStackToString(std::vector<std::string> call_stack) {
+      std::string s_callstack;
+      for (const auto& s : call_stack) {
+          s_callstack += s;
+          s_callstack += ',';
+      }
+      return s_callstack;
+    }
+};
+
+class EventToken: public EventBase {
+  public:
+    int id;
+    std::vector<uint32_t> possible_tokens;
+
+    EventToken(int id):
+      id(id) {}
+
+    // We concretize only at the end, to capture all constraints.
+    void add_possible_token(uint32_t tok) {
+      possible_tokens.push_back(tok);
+    }
+
+    void clear_possible_tokens() {
+      // This is required because EventTokens are shared among forked states.
+      // It should be called during serialization.
+      possible_tokens.clear();
+    }
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventToken\", \"id\": " << id << ", \"possible_tokens\": [";
+      size_t i = 0;
+      for (uint32_t tok: possible_tokens) {
+        json << tok;
+        if (i != possible_tokens.size()-1) json << ", ";
+        i++;
+      }
+      json << "]}";
+      return json.str();
+    }
+};
+
+class EventPassToken: public EventBase {
+  // This event is generated by klee_pass_token.
+  // This is used when we analyze get_next_token in isolation.
+  // We pass the "token id" here.
+  public:
+    uint32_t id;
+
+    EventPassToken(uint32_t id):
+      id(id) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventPassToken\", \"id\": " << id << "}";
+      return json.str();
+    }
+};
+
+class EventCharacter: public EventBase {
+  public:
+    ref<Expr> e;
+    unsigned pos; // position in symbolic input
+    std::vector<std::string> call_stack;
+    std::vector<uint32_t> possible_solutions;
+
+    void add_possible_solution(uint32_t sol) {
+      possible_solutions.push_back(sol);
+    }
+
+    void clear_possible_solutions() {
+      possible_solutions.clear();
+    }
+
+    EventCharacter(ref<Expr> e, unsigned pos, std::vector<std::string> call_stack):
+      e(e), pos(pos), call_stack(call_stack) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventCharacter\", \"inp_pos\": " << pos << ", \"exec_ctx\": \"" << callStackToString(call_stack) << "\", \"possible_solutions\": [";
+      size_t i = 0;
+      for (uint32_t tok: possible_solutions) {
+        json << tok;
+        if (i != possible_solutions.size()-1) json << ", ";
+        i++;
+      }
+      json << "]}";
+      return json.str();
+    }
+};
+
+class EventRevert: public EventBase {
+  public:
+    int count;
+
+    EventRevert(int count):
+      count(count) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventRevert\", \"count\": " << count << "}";
+      return json.str();
+    }
+};
+
+class EventParseCall: public EventBase {
+  public:
+    std::string ppf;
+
+    EventParseCall(std::string ppf):
+      ppf(ppf) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventParseCall\", \"ppf\": \"" << ppf << "\"}";
+      return json.str();
+    }
+};
+
+class EventLoopEntry: public EventBase {
+  public:
+    llvm::BasicBlock* header_bb;
+    int iter_cnt;
+
+    EventLoopEntry(llvm::BasicBlock* header_bb, int iter_cnt):
+      header_bb(header_bb), iter_cnt(iter_cnt) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventLoopEntry\", \"loop_id\": \"" << header_bb << "\", \"iter_cnt\": " << iter_cnt << "}";
+      return json.str();
+    }
+};
+
+class EventLoopExit: public EventBase {
+  public:
+    llvm::BasicBlock* header_bb;
+
+    EventLoopExit(llvm::BasicBlock* header_bb):
+      header_bb(header_bb) {}
+
+    std::string to_json() const override {
+      std::ostringstream json;
+      json << "{\"event\": \"EventLoopExit\", \"loop_id\": \"" << header_bb << "\"}";      
+      return json.str();
+    }
+};
+
+
+
 /// @brief ExecutionState representing a path under exploration
 class ExecutionState {
 #ifdef KLEE_UNITTEST
@@ -240,6 +400,30 @@ public:
   /// @brief Disables forking for this state. Set by user code
   bool forkDisabled = false;
 
+  /// @brief The event stack for all accept, token, loop, ... events.
+  std::vector<EventBase*> eventStack;
+
+  /// @brief The memory object of the cursor pointer.
+  const MemoryObject* mo_cursor;
+
+  /// @brief The offset into the `mo_cursor` where the actual char* cursor is stored [e.g. mo_cursor might point to a struct, or to char** directly]
+  size_t mo_cursor_offset = 0;
+
+  /// @brief The size of the cursor at mo_cursor_offset [usually: sizeof(char*)]
+  size_t mo_cursor_size = 0;
+
+  /// @brief Counts how often "get_next_token" was called.
+  uint64_t token_count = 0;
+
+  /// @brief True if ParserFunctionUnderAnalysis was entered already.
+  bool reachedFUA = false;
+
+  /// @brief highest_input_pos_written - 1 is the last byte accepted, except we're in entry point
+  uint32_t highest_input_pos_written = 0;
+
+  /// @brief Final FUA branch decisions, will be serialized to json.
+  std::vector<bool> finalFunctionPath;
+
 public:
 #ifdef KLEE_UNITTEST
   // provide this function only in the context of unittests
@@ -262,6 +446,7 @@ public:
   void popFrame();
 
   void addSymbolic(const MemoryObject *mo, const Array *array);
+  std::vector<std::string> getCallStack(std::string ParserFunctionUnderAnalysis);
 
   void addConstraint(ref<Expr> e);
   void addCexPreference(const ref<Expr> &cond);
diff --git a/lib/Core/Executor.cpp b/lib/Core/Executor.cpp
index 1187654d..538049cc 100644
--- a/lib/Core/Executor.cpp
+++ b/lib/Core/Executor.cpp
@@ -319,6 +319,18 @@ cl::opt<unsigned long long> MaxInstructions(
     cl::init(0),
     cl::cat(TerminationCat));
 
+cl::list<std::string>
+    ParserFunctions("parser-functions",
+                 cl::desc("List of parser functions, e.g.: term."),
+                cl::cat(klee::ModuleCat));
+
+cl::opt<bool> ByteCursor(
+    "byte-cursor",
+    cl::init(true),
+    cl::desc(
+        "Is cursor (as marked by klee_mark_cursor) byte-level (e.g. for json-parse, GetNextToken exploration)? False indicates token-level cursor (e.g. for tinyc syntax exploration). (default=true)"),
+    cl::cat(SeedingCat));
+
 cl::opt<unsigned>
     MaxForks("max-forks",
              cl::desc("Only fork this many times.  Set to -1 to disable (default=-1)"),
@@ -392,6 +404,32 @@ cl::opt<std::string> TimerInterval(
     cl::init("1s"),
     cl::cat(TerminationCat));
 
+cl::opt<std::string> ParserFunctionUnderAnalysis(
+    "parser-function-under-analysis",
+    cl::desc("The parser function we are currently analyzing. (default: None)"),
+    cl::init("__no__function__with__this__name"),
+    cl::cat(TerminationCat));
+
+cl::opt<std::string> JsonTraceOutputDir(
+    "json-trace-output-dir",
+    cl::desc("The output directory for json trace files. (default: jsons/)"),
+    cl::init("jsons/"),
+    cl::cat(TerminationCat));
+
+cl::opt<std::string> TokenizationFunction(
+    "tokenization-function",
+    cl::desc("The tokenization function of this subject. (default: None)"),
+    cl::init("__no__function__with__this__name"),
+    cl::cat(TerminationCat));
+
+cl::opt<bool> TokenExplorationMode(
+    "token-exploration-mode",
+    cl::desc("Token exploration mode (for token cursor subjects) (default=false)"),
+    cl::init(false),
+    cl::cat(TerminationCat));
+
+
+
 
 /*** Debugging options ***/
 
@@ -446,6 +484,31 @@ cl::opt<bool> DebugCheckForImpliedValues(
 
 } // namespace
 
+
+
+llvm::StringRef getOriginalModuleName(Function &F) {
+  llvm::MDNode *mdNode = F.getMetadata("original_module_name");
+  if (mdNode) {
+    return cast<MDString>(mdNode->getOperand(0))->getString();
+  }
+  return llvm::StringRef("");
+}
+
+bool isUserFunction(Function &F) {
+  llvm::StringRef module_name = getOriginalModuleName(F);
+  if (module_name.endswith(".os"))
+    return false;
+  if (module_name.endswith("_Debug+Asserts.bc"))
+    return false;
+  if (module_name == "")
+    return false;
+  return true;
+}
+
+uint64_t g_json_ctr = 0;
+
+
+
 // XXX hack
 extern "C" unsigned dumpStates, dumpPTree;
 unsigned dumpStates = 0, dumpPTree = 0;
@@ -512,6 +575,18 @@ Executor::Executor(LLVMContext &ctx, const InterpreterOptions &opts,
   }
 }
 
+void setFunctionMetadata(llvm::Function &function, llvm::StringRef payload) {
+  llvm::Module *module = function.getParent();
+
+  // Create a new metadata node
+  llvm::LLVMContext &context = module->getContext();
+  llvm::Metadata *metadata = llvm::MDString::get(context, payload);
+
+  // Set the metadata to the function
+  llvm::MDNode *mdNode = llvm::MDNode::get(context, metadata);
+  function.setMetadata("original_module_name", mdNode);
+}
+
 llvm::Module *
 Executor::setModule(std::vector<std::unique_ptr<llvm::Module>> &modules,
                     const ModuleOptions &opts) {
@@ -532,6 +607,19 @@ Executor::setModule(std::vector<std::unique_ptr<llvm::Module>> &modules,
     klee_error("Could not load KLEE intrinsic file %s", LibPath.c_str());
   }
 
+  // Iterate over modules, add Metadata to each Function that holds the
+  // original ModuleName, since this information won't be preserved after
+  // linking, but it's helpful to analyze only user application code later, not
+  // libc.
+  for (const std::unique_ptr<llvm::Module>&m : modules) { // const -> no copy of unique ptr
+    if (m) {
+      llvm::StringRef moduleName = m->getName();
+      for (llvm::Function &function : m->getFunctionList()) {
+        setFunctionMetadata(function, moduleName);
+      }
+    }
+  }
+
   // 1.) Link the modules together
   while (kmodule->link(modules, opts.EntryPoint)) {
     // 2.) Apply different instrumentation
@@ -1120,6 +1208,8 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
       if (pathWriter) {
         current.pathOS << "1";
       }
+      StackFrame &sf = current.stack.back();
+      sf.functionPath.push_back(true);
     }
 
     return StatePair(&current, nullptr);
@@ -1128,6 +1218,8 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
       if (pathWriter) {
         current.pathOS << "0";
       }
+      StackFrame &sf = current.stack.back();
+      sf.functionPath.push_back(false);
     }
 
     return StatePair(nullptr, &current);
@@ -1193,6 +1285,10 @@ Executor::StatePair Executor::fork(ExecutionState &current, ref<Expr> condition,
         falseState->symPathOS << "0";
       }
     }
+    if (!isInternal) {
+      trueState->stack.back().functionPath.push_back(true);
+      falseState->stack.back().functionPath.push_back(false);
+    }
 
     addConstraint(*trueState, condition);
     addConstraint(*falseState, Expr::createIsZero(condition));
@@ -1909,6 +2005,10 @@ void Executor::executeCall(ExecutionState &state, KInstruction *ki, Function *f,
     // from just an instruction (unlike LLVM).
     KFunction *kf = kmodule->functionMap[f];
 
+    if (f->getName() == ParserFunctionUnderAnalysis || TokenExplorationMode) {
+      state.reachedFUA = true;
+    }
+
     state.pushFrame(state.prevPC, kf);
     state.pc = kf->instructions;
 
@@ -2028,8 +2128,106 @@ void Executor::executeCall(ExecutionState &state, KInstruction *ki, Function *f,
   }
 }
 
+bool Executor::isLoopHeader(BasicBlock* bb) {
+  return kmodule->header_to_exiting_and_exits.count(bb) > 0;
+}
+
+bool Executor::isLoopExitOf(BasicBlock* pot_exit, BasicBlock* header) {
+  std::vector<llvm::BasicBlock*> exit_bbs = kmodule->header_to_exiting_and_exits[header].second;
+  return (std::find(exit_bbs.begin(), exit_bbs.end(), pot_exit) != exit_bbs.end());
+}
+
+EventLoopEntry* Executor::getCurrentLoop(ExecutionState &state) {
+  // This function iterates over the event stack in reverse.
+  // - if LoopEventExit found first: skip all Events until the corresponding LoopEventEntry with iter_cnt = 1 is observed
+  // - else if LoopEventEntry found first: return BasicBlock* of loop header
+  // - else if neither is found: return NULL
+
+  // If needle is != nullptr, this means we're currently skipping things until we find a matching initial EventLoopEntry for a found EventLoopExit.
+  BasicBlock* needle = nullptr;
+
+  for (auto it = state.eventStack.rbegin(); it != state.eventStack.rend(); ++it) {
+    if (EventLoopExit* event_exit = dynamic_cast<EventLoopExit*>(*it)) {
+      if (needle == nullptr) needle = event_exit->header_bb; // Search outmost loop only
+      continue; // E.g. some inner loop terminated, but outer loop could be active still
+    }
+    else if (EventLoopEntry* event_entry = dynamic_cast<EventLoopEntry*>(*it)) {
+      if (needle != nullptr) {
+        if (event_entry->header_bb == needle && event_entry->iter_cnt == 1) {
+          needle = nullptr;
+          continue;
+        }
+      }
+      else {
+        // This is the first found EventLoopEntry, which is not followed by matching EventLoopExit.
+        // a.k.a: The current loop
+        return event_entry;
+      }
+    }
+  }
+
+  // No non-closed loop found.
+  return nullptr;
+}
+
+bool Executor::terminatedDueToLoopBound(BasicBlock *dst, BasicBlock *src, ExecutionState &state) {
+  // <body+header>
+  // print for cases where: exiting jumps to exit; some bb jumps to header (continue)
+  for (auto& pair: kmodule->header_to_exiting_and_exits) {
+    llvm::BasicBlock* header_bb = pair.first;
+    std::vector<llvm::BasicBlock*> exiting_bbs = kmodule->header_to_exiting_and_exits[header_bb].first;
+    std::vector<llvm::BasicBlock*> exit_bbs = kmodule->header_to_exiting_and_exits[header_bb].second;
+    if (std::find(exiting_bbs.begin(), exiting_bbs.end(), src) != exiting_bbs.end()) { // src is some loop's exiting bb
+      if (std::find(exit_bbs.begin(), exit_bbs.end(), dst) != exit_bbs.end()) { // dst is some loop's exit bbs
+        errs() << "Leaving loop body (or header) to exit bb: " << dst << "\n";
+        state.eventStack.push_back(new EventLoopExit(header_bb));
+        break;
+      }
+    }
+  }
+  // </body+header>
+
+
+  // <header>
+  bool terminated = false;
+
+  if (isLoopHeader(dst)) {
+    EventLoopEntry* event_entry = getCurrentLoop(state);
+    if (event_entry == nullptr) { // No ongoing loop
+      // Entering the FUA loop for the first time
+      unsigned cur_loop_iterations = 1;
+      state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
+    } else { // ongoing loop
+      if (event_entry->header_bb == dst) { // Innermost ongoing loop, and we have another iteration of that loop
+        // Entering the FUA loop for the second/third time (e.g. jmp from latch)
+        unsigned cur_loop_iterations = event_entry->iter_cnt + 1;
+
+        if (cur_loop_iterations == 4) {
+          terminated = true;
+          terminateState(state);
+        }
+
+        else {
+          state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
+          assert(cur_loop_iterations <= 4 && "sanity check");
+        }
+      }
+      else {
+        // E.g. We are in outer loop and now entering inner loop
+        unsigned cur_loop_iterations = 1;
+        state.eventStack.push_back(new EventLoopEntry(dst, cur_loop_iterations));
+      }
+    }
+  }
+  // </header>
+  return terminated;
+}
+
 void Executor::transferToBasicBlock(BasicBlock *dst, BasicBlock *src, 
                                     ExecutionState &state) {
+
+  if (terminatedDueToLoopBound(dst, src, state)) return;
+
   // Note that in general phi nodes can reuse phi values from the same
   // block but the incoming value is the eval() result *before* the
   // execution of any phi nodes. this is pathological and doesn't
@@ -2041,7 +2239,7 @@ void Executor::transferToBasicBlock(BasicBlock *dst, BasicBlock *src,
   //
   // With that done we simply set an index in the state so that PHI
   // instructions know which argument to eval, set the pc, and continue.
-  
+
   // XXX this lookup has to go ?
   KFunction *kf = state.stack.back().kf;
   unsigned entry = kf->basicBlockEntry[dst];
@@ -2082,8 +2280,169 @@ Function* Executor::getTargetFunction(Value *calledVal, ExecutionState &state) {
   }
 }
 
+std::vector<uint32_t> Executor::solveExpr(ExecutionState& state, ref<Expr> e, unsigned max_solutions) {
+  ExecutionState* temp_state = state.branch();
+  std::vector<uint32_t> solutions;
+
+  while (solutions.size() < max_solutions) {
+    ref<ConstantExpr> ce;
+    bool success = solver->getValue(temp_state->constraints, e, ce, temp_state->queryMetaData);
+    assert(success);
+    uint64_t sol = ce->getZExtValue();
+    solutions.push_back((uint32_t)sol);
+    ref<Expr> not_sol = NeExpr::create(e, ConstantExpr::create(sol, e->getWidth()));
+
+    bool res;
+    bool _success = solver->mustBeFalse(temp_state->constraints, not_sol, res, temp_state->queryMetaData);
+    assert(_success);
+    if (res) {
+      // Disallowing the current solution would be impossible => This was the last solution => Stop.
+      break;
+    }
+    temp_state->addConstraint(not_sol); // Forcing new solutions
+  }
+
+  return solutions;
+}
+
+std::vector<uint32_t> Executor::getAllTokenSolutions(ExecutionState& state, std::string token_name) {
+  // Forking the ExecutionState here s.t. `addConstraint` below is not persistent.
+  // E.g., when we serialize the sample token multiple times due to lookaheads/reverts, we want to get the full
+  // solution set each time.
+
+  ExecutionState* temp_state = state.branch();
+
+  std::vector<uint32_t> solutions;
+
+  solver->setTimeout(coreSolverTimeout);
+  ConstraintSet extendedConstraints(temp_state->constraints);
+  ConstraintManager cm(extendedConstraints);
+
+  MemoryMap::iterator mi = temp_state->addressSpace.objects.begin();
+  MemoryMap::iterator me = temp_state->addressSpace.objects.end();
+
+  while (mi != me) {
+    const MemoryObject* mo = mi->first;
+    ref<ObjectState> os = mi->second;
+    if (mo->name == token_name) {
+      errs() << "found mo for " << token_name << "\n";
+      while (true) {
+        ref<Expr> e_tok = os->read(ConstantExpr::create(0, Expr::Int32), 8*mo->size);
+        ref<ConstantExpr> ce_sol;
+        bool success = solver->getValue(temp_state->constraints, e_tok, ce_sol, temp_state->queryMetaData);
+        assert(success);
+        uint32_t sol = (uint32_t)ce_sol->getZExtValue();
+        errs() << "Executor::getAllTokenSolutions found a solution: " << sol << "\n";
+
+        solutions.push_back(sol);
+        ref<Expr> not_sol = NeExpr::create(e_tok, ConstantExpr::create(sol, e_tok->getWidth()));
+
+        bool res;
+        bool _success = solver->mustBeFalse(temp_state->constraints, not_sol, res, temp_state->queryMetaData);
+        assert(_success);
+        if (res) {
+          // Disallowing the current solution would be impossible => This was the last solution => Stop.
+          break;
+        }
+
+        temp_state->addConstraint(not_sol); // Forcing new solutions
+      }
+
+      break;
+    }
+    ++mi;
+  }
+
+  solver->setTimeout(time::Span());
+
+  errs() << "Executor::getAllTokenSolutions returned.\n";
+  return solutions;
+}
+
+void Executor::pruneEventCharacters(ExecutionState &state) {
+  std::vector<EventBase*> newEventStack;
+  std::set<unsigned> seen_pos;
+
+  for (size_t i = state.eventStack.size(); i > 0; i--) {
+    EventBase* event = state.eventStack[i-1];
+    if (EventCharacter* event_character = dynamic_cast<EventCharacter*>(event)) {
+      unsigned pos = event_character->pos;
+      if (seen_pos.find(pos) == seen_pos.end()) { // not seen yet
+        // add to front (because we iterate in reverse), so final order is as before.
+        newEventStack.insert(newEventStack.begin(), event);
+        seen_pos.insert(pos);
+      }
+    }
+    else {
+      newEventStack.insert(newEventStack.begin(), event);
+    }
+  }
+  state.eventStack = newEventStack;
+}
+
+void Executor::serialize_eventstack_to_json(ExecutionState &state, bool print) {
+  pruneEventCharacters(state);
+
+  bool first = true;
+  std::ostringstream json;
+
+  json << "{\"functionpath\": \"";
+  for (bool b: state.finalFunctionPath) {
+    if (b) json << "1";
+    else json << "0";
+  }
+  json << "\",\n";
+
+  json << "\"events\": [\n";
+  if (print) errs() << "Serializing eventstack to json...\n";
+  for (size_t i = 0; i < state.eventStack.size(); i++) {
+    EventBase* event = state.eventStack[i];
+    bool skip = false;
+    if (print) errs() << "Event " << i << ":\n";
+    if (EventCharacter* event_character = dynamic_cast<EventCharacter*>(event)) {
+      if (event_character->pos < state.highest_input_pos_written) {
+        event_character->clear_possible_solutions();
+        std::vector<uint32_t> solutions = solveExpr(state, event_character->e, 256);
+        for (uint32_t sol: solutions) {
+          event_character->add_possible_solution(sol);
+        }
+      } else skip = true;
+    }
+    else if (EventToken* event_token = dynamic_cast<EventToken*>(event)) {
+      event_token->clear_possible_tokens();
+      std::string sym_var = "tok_" + std::to_string(event_token->id);
+      std::vector<uint32_t> solutions = getAllTokenSolutions(state, sym_var);
+      for (uint32_t sol: solutions) {
+        event_token->add_possible_token(sol);
+      }
+    }
+    if (!skip) {
+      if (!first) {
+        json << ",";
+      } else {
+        first = false;
+      }
+      json << "\t" << event->to_json();
+      json << "\n";
+
+      if (print) errs() << "\t" << event->to_json() << "\n";
+    }
+  }
+
+  json << "]}\n";
+
+  // Serialize json
+  //std::ofstream outputFile("jsons/" + ParserFunctionUnderAnalysis + "-" + std::to_string(g_json_ctr++) +".json");
+  std::ofstream outputFile(JsonTraceOutputDir + ParserFunctionUnderAnalysis + "-" + std::to_string(g_json_ctr++) +".json");
+  if (outputFile.is_open()) {
+    outputFile << json.str();
+    outputFile.close();
+  }
+}
+
 void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
   Instruction *i = ki->inst;
+
   switch (i->getOpcode()) {
     // Control flow
   case Instruction::Ret: {
@@ -2092,6 +2451,25 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     Instruction *caller = kcaller ? kcaller->inst : nullptr;
     bool isVoidReturn = (ri->getNumOperands() == 0);
     ref<Expr> result = ConstantExpr::alloc(0, Expr::Bool);
+
+    if (ri && ri->getFunction() && (ri->getFunction()->getName() == ("__user_" + entrypoint))) {
+      // We wait for the KLEE WRAPPER function (kw_) to return, which implements the 
+      // function-level syntax error oracle (and in fact does not return if it detects
+      // a syntax error).
+      // The "__user_" prefix is added by KLEE.
+      errs() << "<FUA returned>\n";
+      serialize_eventstack_to_json(state, false);
+      errs() << "</FUA returned>\n";
+    }
+
+    if (ri && ri->getFunction() && (ri->getFunction()->getName() == ParserFunctionUnderAnalysis)) {
+      // The parser function under analysis returns to klee wrapper.
+      // We store the `functionPath` of this function.
+      assert(state.finalFunctionPath.empty());
+      StackFrame &sf = state.stack.back();
+      state.finalFunctionPath = sf.functionPath;
+    }
+
     
     if (!isVoidReturn) {
       result = eval(ki, 0, state).value;
@@ -2201,10 +2579,12 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
       if (statsTracker && state.stack.back().kf->trackCoverage)
         statsTracker->markBranchVisited(branches.first, branches.second);
 
-      if (branches.first)
+      if (branches.first) {
         transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
-      if (branches.second)
+      }
+      if (branches.second) {
         transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
+      }
     }
     break;
   }
@@ -2394,8 +2774,9 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
                                                ie = bbOrder.end();
            it != ie; ++it) {
         ExecutionState *es = *bit;
-        if (es)
+        if (es) {
           transferToBasicBlock(*it, bb, *es);
+        }
         ++bit;
       }
     }
@@ -2427,6 +2808,49 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     for (unsigned j=0; j<numArgs; ++j)
       arguments.push_back(eval(ki, j+1, state).value);
 
+    for (const auto &pf : ParserFunctions) {
+      if (f && f->getName() == pf) {
+        auto caller_function = i->getFunction()->getName().str();
+        if (caller_function == "__klee_posix_wrapped_main") {
+          // This is the entrypoint initially calling the FUA => Do not redirect or output.
+          break;
+        }
+        if (caller_function != ParserFunctionUnderAnalysis) {
+          errs() << "Error: " << i->getFunction()->getName() << " called " << pf << "\n";
+          klee_error("Non-FUA called PPF");
+        }
+
+        state.eventStack.push_back(new EventParseCall(pf));
+
+        // Detour parser functions to corresponding symbolic proxy
+        for (auto &kf: kmodule->functions) {
+          // errs() << "All functions: " << kf->function->getName().str() << "\n";
+          if (kf->function->getName().str() == "sym_"+f->getName().str()) {
+            errs() << "Redirecting call to sym_" << f->getName() << "\n";
+            f = kf->function;
+            break;
+          }
+        }
+        break;
+      }
+    }
+
+    // We push EventToken and do the increment on handleGetNextTokenCtr now.
+
+    // Detour `GetNextToken` function
+    if (!ByteCursor) {
+      if (f && f->getName().str() == TokenizationFunction) {
+        for (auto &kf: kmodule->functions) {
+          if (kf->function->getName().str() == "sym_"+f->getName().str()) {
+            errs() << "Redirecting call to sym. tokenization function sym_" << f->getName() << "\n";
+            f = kf->function;
+            break;
+          }
+        }
+      }
+    }
+
+
     if (auto* asmValue = dyn_cast<InlineAsm>(fp)) { //TODO: move to `executeCall`
       if (ExternalCalls != ExternalCallPolicy::None) {
         KInlineAsm callable(asmValue);
@@ -2779,6 +3203,7 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     if (kgepi->offset)
       base = AddExpr::create(base,
                              Expr::createPointer(kgepi->offset));
+    
     bindLocal(ki, state, base);
     break;
   }
@@ -4230,6 +4655,79 @@ void Executor::executeMemoryOperation(ExecutionState &state,
           terminateStateOnError(state, "memory error: object read only",
                                 StateTerminationType::ReadOnly);
         } else {
+          if (!ByteCursor) { // Token Cursor
+            if (mo == state.mo_cursor) {
+              if (isa<ConstantExpr>(offset) && cast<ConstantExpr>(offset)->getZExtValue() == state.mo_cursor_offset) {
+                // new value:
+                std::vector<const Array *> new_objects;
+                findSymbolicObjects(value, new_objects);
+                // Some parsers are not well behaved in a sense that they write a constant (such as ERROR) to the token cursor 
+                // from a parse function, i.e. not via the singular tokenization function. In this case the written value is not
+                // a symbolic object, so new_objects.size() == 0. We catch this case here.
+                if (new_objects.size() == 0) {
+                  errs() << "Write concrete object to token cursor, ignoring\n";
+                } else {
+                  assert(new_objects.size() == 1);
+                  errs() << "new cursor: " << new_objects[0]->name << "\n";
+
+                  // old value:
+                  std::vector<const Array *> old_objects;
+                  ref<Expr> e_old_value = os->read(ConstantExpr::create(state.mo_cursor_offset, Expr::Int32), 8*state.mo_cursor_size);
+                  findSymbolicObjects(e_old_value, old_objects);
+                  assert(old_objects.size() <= 1);
+                  if (old_objects.size() == 0) errs() << "old cursor: None\n";
+                  else errs() << "old cursor: " << old_objects[0]->name << "\n";
+
+                  if (old_objects.size() == 1 && new_objects.size() == 1) {
+                    std::string old_tok_var = old_objects[0]->name;
+                    std::string new_tok_var = new_objects[0]->name;
+                    std::string prefix = "tok_";
+                    assert(old_tok_var.substr(0, prefix.length()) == prefix);
+                    assert(new_tok_var.substr(0, prefix.length()) == prefix);
+                    int old_tok_ctr = std::stoi(old_tok_var.substr(prefix.length()));
+                    int new_tok_ctr = std::stoi(new_tok_var.substr(prefix.length()));
+                    errs() << "old_tok_ctr: " << old_tok_ctr << " new_tok_ctr: " << new_tok_ctr << "\n";
+                    // TODO: Maybe push EventToken here, which we currently do in handleGetNextTokenCtr.
+                    if (new_tok_ctr == old_tok_ctr+1) { /*OK*/ }
+                    else if (new_tok_ctr == old_tok_ctr) { /*OK*/ }
+                    else if (new_tok_ctr < old_tok_ctr) {
+                      state.eventStack.push_back(new EventRevert(old_tok_ctr - new_tok_ctr));
+                      state.token_count = new_tok_ctr;
+                    }
+                    else {
+                      errs() << "not OK\n";
+                      assert(false);
+                    }
+                  }
+                }
+              }
+            }
+          } else { // Byte Cursor
+            ObjectPair op;
+            if (ConstantExpr *CE = dyn_cast<ConstantExpr>(value)) {
+              // KLEE will fail an assertion in getZExtValue for width > 64 bit
+              // Pointers are always <= 64 bit, so this is fine.
+              if (CE->getWidth() <= 64) {
+                if (state.addressSpace.resolveOne(CE, op)) {
+                  const MemoryObject *mo = op.first;
+                  const ObjectState *os = op.second;
+                  ref<Expr> offset_expr = mo->getOffsetExpr(CE);
+                  size_t offset = cast<ConstantExpr>(offset_expr)->getZExtValue();
+                  if (state.reachedFUA && mo->name == "input_str") { // Hard coded name in klee wrappers
+                    // If we *write* (currently: for the first time) an the addr of inp[i+1], we consider this an access to inp[i].
+                    if (offset > 0) {
+                      if (state.highest_input_pos_written < offset) {
+                        ref<Expr> e = os->read8(offset-1);
+                        state.eventStack.push_back(new EventCharacter(e, offset-1, state.getCallStack(ParserFunctionUnderAnalysis)));
+                      }
+                    }
+                    state.highest_input_pos_written = std::max(state.highest_input_pos_written, (uint32_t)offset);
+                  }
+                }
+              }
+            }
+          }
+
           ObjectState *wos = state.addressSpace.getWriteable(mo, os);
           wos->write(offset, value);
         }          
@@ -4382,6 +4880,8 @@ void Executor::runFunctionAsMain(Function *f,
 				 char **envp) {
   std::vector<ref<Expr> > arguments;
 
+  entrypoint = f->getName().str();
+
   // force deterministic initialization of memory objects
   srand(1);
   srandom(1);
diff --git a/lib/Core/Executor.h b/lib/Core/Executor.h
index 279d8bee..48115eff 100644
--- a/lib/Core/Executor.h
+++ b/lib/Core/Executor.h
@@ -119,6 +119,8 @@ private:
   TimerGroup timers;
   std::unique_ptr<PTree> processTree;
 
+  std::string entrypoint;
+
   /// Used to track states that have been added during the current
   /// instructions step. 
   /// \invariant \ref addedStates is a subset of \ref states. 
@@ -215,6 +217,15 @@ private:
   llvm::Function* getTargetFunction(llvm::Value *calledVal,
                                     ExecutionState &state);
   
+  bool terminatedDueToLoopBound(llvm::BasicBlock *dst, llvm::BasicBlock *src, ExecutionState &state);
+  bool isLoopHeader(llvm::BasicBlock* bb);
+  bool isLoopExitOf(llvm::BasicBlock* pot_exit, llvm::BasicBlock* header);
+  EventLoopEntry* getCurrentLoop(ExecutionState &state);
+  std::vector<uint32_t> solveExpr(ExecutionState& state, ref<Expr> e, unsigned max_solutions);
+  std::vector<uint32_t> getAllTokenSolutions(ExecutionState& state, std::string token_name);
+  void serialize_eventstack_to_json(ExecutionState &state, bool print);
+  void pruneEventCharacters(ExecutionState &state);
+
   void executeInstruction(ExecutionState &state, KInstruction *ki);
 
   void run(ExecutionState &initialState);
@@ -313,6 +324,7 @@ private:
                    llvm::Function *f,
                    std::vector< ref<Expr> > &arguments);
                    
+  
   // do address resolution / object binding / out of bounds checking
   // and perform the operation
   void executeMemoryOperation(ExecutionState &state,
diff --git a/lib/Core/SpecialFunctionHandler.cpp b/lib/Core/SpecialFunctionHandler.cpp
index f4b09f36..c8d0251b 100644
--- a/lib/Core/SpecialFunctionHandler.cpp
+++ b/lib/Core/SpecialFunctionHandler.cpp
@@ -102,6 +102,9 @@ static SpecialFunctionHandler::HandlerInfo handlerInfo[] = {
 #endif
   add("klee_is_symbolic", handleIsSymbolic, true),
   add("klee_make_symbolic", handleMakeSymbolic, false),
+  add("klee_mark_cursor", handleMarkCursor, false),
+  add("klee_pass_token", handlePassToken, false),
+  add("klee_get_next_token_ctr", handleGetNextTokenCtr, true),
   add("klee_mark_global", handleMarkGlobal, false),
   add("klee_open_merge", handleOpenMerge, false),
   add("klee_close_merge", handleCloseMerge, false),
@@ -855,6 +858,59 @@ void SpecialFunctionHandler::handleMakeSymbolic(ExecutionState &state,
   }
 }
 
+void SpecialFunctionHandler::handleMarkCursor(ExecutionState &state,
+                                            KInstruction *target,
+                                            std::vector<ref<Expr> > &arguments) {
+  assert(arguments.size()==2 &&
+         "invalid number of arguments to klee_mark_cursor. Usage: klee_mark_cursor(char** pCursor, size_t [usually sizeof(char*)])");
+
+  errs() << "klee_mark_cursor called on " << arguments[0] << "\n";
+
+  ref<ConstantExpr> address = cast<ConstantExpr>(arguments[0]);
+  ObjectPair op;
+  if (!state.addressSpace.resolveOne(address, op)) {
+    errs() << "!resolveOne\n";
+    assert(false);
+  }
+
+  size_t cursor_size = cast<ConstantExpr>(arguments[1])->getZExtValue();
+
+  const MemoryObject *mo = op.first;
+  // const ObjectState *os = op.second;
+  auto relativeOffset = mo->getOffsetExpr(address);
+  // the relativeOffset must be concrete as the address is concrete
+  size_t offset = cast<ConstantExpr>(relativeOffset)->getZExtValue();
+  state.mo_cursor = mo;
+  state.mo_cursor_offset = offset;
+  state.mo_cursor_size = cursor_size;
+  errs() << "klee_mark_cursor found object: " << mo->name << " at " << mo->address << " size=" << mo->size << "\n";
+  errs() << "klee_mark_cursor offset: " << state.mo_cursor_offset << " size " << state.mo_cursor_size << "\n";
+}
+
+void SpecialFunctionHandler::handlePassToken(ExecutionState &state,
+                                            KInstruction *target,
+                                            std::vector<ref<Expr> > &arguments) {
+  assert(arguments.size()==1 &&
+         "invalid number of arguments to klee_pass_token. Usage: klee_pass_token(int token)");
+
+  errs() << "klee_pass_token called on " << arguments[0] << "\n";
+  ref<ConstantExpr> token_id = cast<ConstantExpr>(arguments[0]);
+  state.eventStack.push_back(new EventPassToken(token_id->getZExtValue()));
+}
+
+
+// get_next_token functions must call this once.
+void SpecialFunctionHandler::handleGetNextTokenCtr(ExecutionState &state,
+                                            KInstruction *target,
+                                            std::vector<ref<Expr> > &arguments) {
+  assert(arguments.size()==0 &&
+         "invalid number of arguments to klee_get_next_token_ctr");
+  state.token_count++;
+  state.eventStack.push_back(new EventToken(state.token_count));
+  executor.bindLocal(target, state, ConstantExpr::create(state.token_count, Expr::Int32));
+}
+
+
 void SpecialFunctionHandler::handleMarkGlobal(ExecutionState &state,
                                               KInstruction *target,
                                               std::vector<ref<Expr> > &arguments) {
diff --git a/lib/Core/SpecialFunctionHandler.h b/lib/Core/SpecialFunctionHandler.h
index 9487fdf5..7339cb8e 100644
--- a/lib/Core/SpecialFunctionHandler.h
+++ b/lib/Core/SpecialFunctionHandler.h
@@ -125,6 +125,10 @@ namespace klee {
     HANDLER(handleMakeSymbolic);
     HANDLER(handleMalloc);
     HANDLER(handleMemalign);
+    HANDLER(handleMarkCursor);
+    HANDLER(handlePassToken);
+    HANDLER(handleGetNextTokenCtr);
+    HANDLER(handleGetNextToken);
     HANDLER(handleMarkGlobal);
     HANDLER(handleOpenMerge);
     HANDLER(handleCloseMerge);
diff --git a/lib/Expr/ExprUtil.cpp b/lib/Expr/ExprUtil.cpp
index 3819e3a2..b3655788 100644
--- a/lib/Expr/ExprUtil.cpp
+++ b/lib/Expr/ExprUtil.cpp
@@ -118,8 +118,60 @@ ExprVisitor::Action ConstantArrayFinder::visitRead(const ReadExpr &re) {
 
   return Action::doChildren();
 }
+
+class SymbolicObjectIndexFinder : public ExprVisitor {
+protected:
+  Action visitRead(const ReadExpr &re) {
+    const UpdateList &ul = re.updates;
+
+    // XXX should we memo better than what ExprVisitor is doing for us?
+    for (const auto *un = ul.head.get(); un; un = un->next.get()) {
+      visit(un->index);
+      visit(un->value);
+    }
+
+    if (ul.root->isSymbolicArray()) {
+      //if (results.insert(ul.root).second)
+      objects.push_back(ul.root);
+      updatelists.push_back(ul);
+      indices.push_back(re.index);
+    }
+
+    return Action::doChildren();
+  }
+
+public:
+  std::set<const Array*> results;
+  std::vector<const Array*> &objects;
+  std::vector<UpdateList> &updatelists;
+  std::vector<ref<Expr>> &indices;
+
+  SymbolicObjectIndexFinder(std::vector<const Array*> &_objects, std::vector<UpdateList> &_updatelists, std::vector<ref<Expr>> &_indices)
+    : objects(_objects), updatelists(_updatelists), indices(_indices) {}
+};
+
+
+}
+
+template<typename InputIterator>
+void klee::findSymbolicObjectIndices(InputIterator begin, 
+                               InputIterator end,
+                               std::vector<const Array*> &results_arrays,
+                               std::vector<UpdateList> &updatelists,
+                               std::vector<ref<Expr>> &indices) {
+  SymbolicObjectIndexFinder of(results_arrays, updatelists, indices);
+  for (; begin!=end; ++begin)
+    of.visit(*begin);
+}
+
+void klee::findSymbolicObjectIndices(ref<Expr> e,
+                               std::vector<const Array*> &results_arrays,
+                               std::vector<UpdateList> &updatelists,
+                               std::vector<ref<Expr>> &indices) {
+  findSymbolicObjectIndices(&e, &e+1, results_arrays, updatelists, indices);
 }
 
+
 template<typename InputIterator>
 void klee::findSymbolicObjects(InputIterator begin, 
                                InputIterator end,
diff --git a/lib/Module/CMakeLists.txt b/lib/Module/CMakeLists.txt
index 6c2a24b3..b9caf3d7 100644
--- a/lib/Module/CMakeLists.txt
+++ b/lib/Module/CMakeLists.txt
@@ -20,6 +20,7 @@ set(KLEE_MODULE_COMPONENT_SRCS
   OptNone.cpp
   PhiCleaner.cpp
   RaiseAsm.cpp
+  ParserLoopAnalysis.cpp
 )
 
 klee_add_component(kleeModule
diff --git a/lib/Module/KModule.cpp b/lib/Module/KModule.cpp
index 2e96c68a..b5a77fc0 100644
--- a/lib/Module/KModule.cpp
+++ b/lib/Module/KModule.cpp
@@ -50,6 +50,10 @@ namespace klee {
 cl::OptionCategory
     ModuleCat("Module-related options",
               "These options affect the compile-time processing of the code.");
+
+cl::OptionCategory
+    StaticGrammarMiningCat("Static grammar mining-related options",
+              "These options affect static analysis related to grammar mining.");
 }
 
 namespace {
@@ -98,6 +102,13 @@ namespace {
                              cl::desc("Allow optimization of functions that "
                                       "contain KLEE calls (default=true)"),
                              cl::init(true), cl::cat(ModuleCat));
+
+cl::opt<bool> StaticGrammarMining(
+    "static-grammar-mining",
+    cl::desc(
+        "Static Grammar Mining mode, runs ReachbleParseFunctions pass (default=false)"), // to be used in conjunction with --entrypoint (default=false)"),
+    cl::init(false),
+    cl::cat(StaticGrammarMiningCat));
 }
 
 /***/
@@ -278,7 +289,15 @@ void KModule::optimiseAndPrepare(
   pm3.add(createScalarizerPass());
   pm3.add(new PhiCleanerPass());
   pm3.add(new FunctionAliasPass());
+
+  if (StaticGrammarMining) pm3.add(createUnifyLoopExitsPass()); // Required s.t. all loops have one exit
+  if (StaticGrammarMining) pm3.add(new ParserLoopAnalysis(header_to_exiting_and_exits));
+
   pm3.run(*module);
+
+  for (const auto &pair: header_to_exiting_and_exits) {
+    errs() << "Extracted loop header: " << pair.first << "\n";
+  }
 }
 
 void KModule::manifest(InterpreterHandler *ih, bool forceSourceOutput) {
diff --git a/lib/Module/ParserLoopAnalysis.cpp b/lib/Module/ParserLoopAnalysis.cpp
new file mode 100644
index 00000000..b91601fe
--- /dev/null
+++ b/lib/Module/ParserLoopAnalysis.cpp
@@ -0,0 +1,171 @@
+//===-- ParserLoopAnalysis.cpp
+//-------------------------------------------------------===//
+
+#include "Passes.h"
+
+#include "klee/Core/Interpreter.h"
+//#include "klee/Config/Version.h"
+#include "llvm/Pass.h"
+//#include "llvm/PassAnalysisSupport.h"
+#include "llvm/IR/Dominators.h"
+
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/Analysis/TargetLibraryInfo.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/CFG.h"
+// #include "llvm/IR/CallSite.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/raw_ostream.h"
+
+
+#include <cassert>
+#include <fstream>
+#include <iomanip>
+#include <map>
+#include <set>
+#include <vector>
+#include <regex>
+
+using namespace llvm;
+using namespace klee;
+
+cl::OptionCategory
+    StaticGrammarMiningCat("Static grammar mining-related options",
+              "These options affect static analysis related to grammar mining.");
+
+namespace {
+    cl::opt<std::string>
+        FUA("llvm-pass-parser-function-under-analysis",
+                cl::desc("Function name of the parser function under analysis point (default: None)."),
+                cl::init("__no__function__with__this__name"),
+                cl::cat(StaticGrammarMiningCat));
+}
+
+
+namespace klee {
+
+char ParserLoopAnalysis::ID;
+
+////////////////////////////
+/////////  Helpers /////////
+////////////////////////////
+
+std::string get_source_filename(Function& F) {
+    SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;
+    F.getAllMetadata(MDs);
+    for (auto &MD : MDs) {
+        if (MDNode *N = MD.second) {
+            if (auto *subProgram = dyn_cast<DISubprogram>(N)) {
+                return subProgram->getFilename().str();
+            }
+        }
+    }
+    return "";
+}
+
+llvm::StringRef getOriginalModuleName(Function &F) {
+  llvm::MDNode *mdNode = F.getMetadata("original_module_name");
+  if (mdNode) {
+    return cast<MDString>(mdNode->getOperand(0))->getString();
+  }
+  return llvm::StringRef("");
+}
+
+bool isUserFunction(Function &F) {
+  llvm::StringRef module_name = getOriginalModuleName(F);
+  if (module_name.endswith(".os"))
+    return false;
+  if (module_name.endswith("_Debug+Asserts.bc"))
+    return false;
+  if (module_name == "")
+    return false;
+  return true;
+}
+
+////////////////////////////
+/////////  Passes /////////
+////////////////////////////
+
+
+void ParserLoopAnalysis::getAnalysisUsage(
+    llvm::AnalysisUsage &AU) const {
+  AU.addRequired<llvm::LoopInfoWrapperPass>();
+}
+
+bool ParserLoopAnalysis::runOnFunction(Function &F) {
+    if (FUA == "__no__function__with__this__name") return false;
+    if (F.getName() != FUA) return false;
+
+    errs() << "ParserLoopAnalysis called." << "\n";
+
+    LoopInfo &LI = getAnalysis<llvm::LoopInfoWrapperPass>().getLoopInfo();
+
+    std::vector<Loop*> queue;
+    for (Loop* L: LI) {
+      queue.push_back(L);
+    }
+
+    while (!queue.empty()) {
+      Loop* L = queue.front();
+      queue.erase(queue.begin()); // Pop first element
+      for (auto it = L->getSubLoops().begin(); it !=  L->getSubLoops().end(); ++it) {
+        queue.push_back(*it);
+      }
+
+      errs() << "Processing a loop in function " << F.getName() << ":\n";
+      BasicBlock* header = L->getHeader();
+      errs() << "Header: " << *header << "\n";
+      
+      errs() << "Exiting blocks for loop:\n";
+      SmallVector<BasicBlock *, 8> ExitingBlocks;
+      L->getExitingBlocks(ExitingBlocks);
+
+      int i=0;
+      for (BasicBlock *BB : ExitingBlocks) {
+        errs() << "Exiting BB" << i << ":\n";
+        BB->print(errs());
+        errs() << "\n";
+        errs() << "Terminator: " << *(BB->getTerminator()) << "\n";
+        i++;
+      }
+
+      errs() << "Exit blocks for loop (outside):\n";
+      SmallVector<BasicBlock *, 8> ExitBlocks;
+      L->getExitBlocks(ExitBlocks);
+      // NOTE: There may be duplicates in ExitBlocks.
+      // It's just all the successor blocks of all branches that may exit the loop.
+      // So if we have multiple `break;` statements, for example, these will be duplicated.
+      i = 0;
+      for (BasicBlock *BB : ExitBlocks) {
+        errs() << "Exit BB" << i << ":\n";
+        BB->print(errs());
+        errs() << "\n";
+        errs() << "Terminator: " << *(BB->getTerminator()) << "\n";
+        i++;
+      }
+
+      std::vector<BasicBlock*> UniqueExitingBlocks(ExitingBlocks.begin(), ExitingBlocks.end()); // always unique
+      std::vector<BasicBlock*> UniqueExitBlocks;
+      for (BasicBlock* BB: ExitBlocks) {
+        if (std::find(UniqueExitBlocks.begin(), UniqueExitBlocks.end(), BB) == UniqueExitBlocks.end()) {
+          UniqueExitBlocks.push_back(BB);
+        }
+      }
+
+      assert(UniqueExitBlocks.size() == 1 && "Loops must have exactly 1 exit BB currently.");
+
+      header_to_exiting_and_exits[header] = std::make_pair(UniqueExitingBlocks, UniqueExitBlocks);
+    }
+
+    return false;
+}
+
+
+
+} // namespace klee
\ No newline at end of file
diff --git a/lib/Module/Passes.h b/lib/Module/Passes.h
index 3eb43ec3..e041cb0e 100644
--- a/lib/Module/Passes.h
+++ b/lib/Module/Passes.h
@@ -192,6 +192,16 @@ public:
   OptNonePass() : llvm::ModulePass(ID) {}
   bool runOnModule(llvm::Module &M) override;
 };
+
+class ParserLoopAnalysis : public llvm::FunctionPass {
+public:
+  static char ID;
+  std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> &header_to_exiting_and_exits; // map header bb to exiting, exit bbs // OUTPUT
+  ParserLoopAnalysis(std::map<llvm::BasicBlock*, std::pair<std::vector<llvm::BasicBlock*>,std::vector<llvm::BasicBlock*>>> &T) : llvm::FunctionPass(ID), header_to_exiting_and_exits(T) {}
+  void getAnalysisUsage(llvm::AnalysisUsage &AU) const;
+  bool runOnFunction(llvm::Function &F) override;
+};
+
 } // namespace klee
 
 #endif /* KLEE_PASSES_H */
diff --git a/tools/klee/main.cpp b/tools/klee/main.cpp
index 7d938ab2..244da123 100644
--- a/tools/klee/main.cpp
+++ b/tools/klee/main.cpp
@@ -768,7 +768,11 @@ static const char *modelledExternals[] = {
   "klee_get_obj_size",
   "klee_is_symbolic",
   "klee_make_symbolic",
+  "klee_pass_cursor",
+  "klee_pass_token",
+  "klee_get_next_token_ctr",
   "klee_mark_global",
+  "klee_mark_cursor",
   "klee_open_merge",
   "klee_close_merge",
   "klee_prefer_cex",
